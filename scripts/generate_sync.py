#!/usr/bin/env python3
"""Generate sync versions of async modules using AST transformation.

This script transforms async code (aioboto3) to sync code (boto3) by:
- Removing async/await keywords
- Renaming classes (RateLimiter -> SyncRateLimiter)
- Rewriting imports (aioboto3 -> boto3)

Generated files are committed to git and verified by CI.
"""

import ast
import re
import subprocess
import sys
from pathlib import Path

# Project root
ROOT = Path(__file__).parent.parent
SRC = ROOT / "src" / "zae_limiter"

# Files to transform: (source, target)
SOURCE_TRANSFORMS = [
    ("repository_protocol.py", "sync_repository_protocol.py"),
    ("repository.py", "sync_repository.py"),
    ("limiter.py", "sync_limiter.py"),
    ("lease.py", "sync_lease.py"),
    ("config_cache.py", "sync_config_cache.py"),
    ("infra/stack_manager.py", "infra/sync_stack_manager.py"),
    ("infra/discovery.py", "infra/sync_discovery.py"),
]

# Class renames
CLASS_RENAMES = {
    "RepositoryProtocol": "SyncRepositoryProtocol",
    "RateLimiter": "SyncRateLimiter",
    "Repository": "SyncRepository",
    "Lease": "SyncLease",
    "ConfigCache": "SyncConfigCache",
    "StackManager": "SyncStackManager",
    "InfrastructureDiscovery": "SyncInfrastructureDiscovery",
}

# Import module rewrites (also used for Name references like aioboto3.Session)
IMPORT_MODULE_REWRITES = {
    "aioboto3": "boto3",
}

# Method name rewrites for context manager calls
METHOD_NAME_REWRITES = {
    "__aenter__": "__enter__",
    "__aexit__": "__exit__",
}

# Attribute name rewrites (e.g., _async_lock -> _sync_lock)
ATTRIBUTE_NAME_REWRITES = {
    "_async_lock": "_sync_lock",
}

# Attribute access rewrites (module.attr -> replacement)
# Used for asyncio.Lock -> threading.Lock, asyncio.sleep -> time.sleep
ATTRIBUTE_ACCESS_REWRITES = {
    ("asyncio", "Lock"): ("threading", "Lock"),
    ("asyncio", "sleep"): ("time", "sleep"),
}

# Import path rewrites (for relative imports)
IMPORT_PATH_REWRITES = {
    ".repository_protocol": ".sync_repository_protocol",
    ".repository": ".sync_repository",
    ".lease": ".sync_lease",
    ".config_cache": ".sync_config_cache",
    ".infra.stack_manager": ".infra.sync_stack_manager",
    ".infra.discovery": ".infra.sync_discovery",
}

# Names to rewrite in from imports
IMPORT_NAME_REWRITES = {
    "RepositoryProtocol": "SyncRepositoryProtocol",
    "Repository": "SyncRepository",
    "Lease": "SyncLease",
    "ConfigCache": "SyncConfigCache",
    "StackManager": "SyncStackManager",
    "InfrastructureDiscovery": "SyncInfrastructureDiscovery",
    # Decorator rewrites
    "asynccontextmanager": "contextmanager",
}

# Type annotation rewrites
TYPE_REWRITES = {
    "AsyncIterator": "Iterator",
    "AsyncContextManager": "ContextManager",
    "AsyncGenerator": "Generator",
}

# Subscript type unwrapping (e.g., Awaitable[X] -> X, Coroutine[Any, Any, X] -> X)
UNWRAP_SUBSCRIPTS = {"Awaitable", "Coroutine"}

# Methods/functions to remove (already have sync equivalents)
REMOVE_METHODS = {
    "get_system_defaults_sync",
    "get_resource_defaults_sync",
    "get_entity_limits_sync",
    "invalidate_sync",
}

# Classes to skip (import from async module instead of duplicating).
# Prevents enum identity mismatches when both modules define the same enum.
# Maps class name -> source module for the import statement.
SKIP_CLASS_DEFINITIONS = {
    "OnUnavailable": ".limiter",
}

GENERATED_HEADER = '''"""AUTO-GENERATED by scripts/generate_sync.py - DO NOT EDIT.

Source: {source_file}

This module provides synchronous versions of the async classes.
Changes should be made to the source file, then regenerated.
"""

'''


class AsyncToSyncTransformer(ast.NodeTransformer):
    """Transform async Python code to sync."""

    def __init__(self, source_file: str):
        self.source_file = source_file
        super().__init__()

    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> ast.FunctionDef:  # noqa: N802
        """Convert async def to def."""
        # Transform the body first
        new_body = [self.visit(stmt) for stmt in node.body]

        # Handle __aenter__ -> __enter__, __aexit__ -> __exit__
        new_name = node.name
        if new_name == "__aenter__":
            new_name = "__enter__"
        elif new_name == "__aexit__":
            new_name = "__exit__"

        # Transform argument annotations (for Awaitable[X] -> X, etc.)
        for arg in node.args.args:
            if arg.annotation:
                arg.annotation = self._transform_annotation(arg.annotation)
        for arg in node.args.posonlyargs:
            if arg.annotation:
                arg.annotation = self._transform_annotation(arg.annotation)
        for arg in node.args.kwonlyargs:
            if arg.annotation:
                arg.annotation = self._transform_annotation(arg.annotation)
        if node.args.vararg and node.args.vararg.annotation:
            node.args.vararg.annotation = self._transform_annotation(node.args.vararg.annotation)
        if node.args.kwarg and node.args.kwarg.annotation:
            node.args.kwarg.annotation = self._transform_annotation(node.args.kwarg.annotation)

        # Create sync function
        new_node = ast.FunctionDef(
            name=new_name,
            args=node.args,
            body=new_body,
            decorator_list=[self.visit(d) for d in node.decorator_list],
            returns=self._transform_annotation(node.returns) if node.returns else None,
            type_comment=node.type_comment,
        )
        return ast.copy_location(new_node, node)

    def visit_Await(self, node: ast.Await) -> ast.AST:  # noqa: N802
        """Remove await, keep the expression."""
        return self.visit(node.value)

    def visit_Call(self, node: ast.Call) -> ast.AST:  # noqa: N802
        """Handle special function call transformations."""
        # First visit children
        node.func = self.visit(node.func)
        node.args = [self.visit(arg) for arg in node.args]
        node.keywords = [self.visit(kw) for kw in node.keywords]

        # Handle asyncio.wait_for(coro, timeout) -> just coro (remove wait_for)
        if (
            isinstance(node.func, ast.Attribute)
            and isinstance(node.func.value, ast.Name)
            and node.func.value.id == "asyncio"
            and node.func.attr == "wait_for"
            and len(node.args) >= 1
        ):
            # Return just the first argument (the coroutine), skip timeout
            return node.args[0]

        # Handle boto3/aioboto3 client context manager pattern:
        # session.client("dynamodb", ...)__aenter__() -> session.client("dynamodb", ...)
        # After __aenter__ -> __enter__ rewrite, we get .__enter__() which we need to remove
        # for boto3 sync clients (they're not context managers)
        if (
            isinstance(node.func, ast.Attribute)
            and node.func.attr == "__enter__"
            and isinstance(node.func.value, ast.Call)
            and isinstance(node.func.value.func, ast.Attribute)
            and node.func.value.func.attr == "client"
        ):
            # Remove the .__enter__() call, return just the client creation
            return node.func.value

        return node

    def visit_Expr(self, node: ast.Expr) -> ast.AST | None:  # noqa: N802
        """Handle expression statements, removing boto3 __exit__ calls."""
        # Visit the expression first
        node.value = self.visit(node.value)

        # Remove self._client.__exit__(None, None, None) calls
        # boto3 sync clients don't have __exit__ - they don't need explicit cleanup
        if (
            isinstance(node.value, ast.Call)
            and isinstance(node.value.func, ast.Attribute)
            and node.value.func.attr == "__exit__"
        ):
            # Replace with pass (we can't just remove the statement)
            return ast.Pass()

        return node

    def visit_AsyncWith(self, node: ast.AsyncWith) -> ast.AST:  # noqa: N802
        """Convert async with to with, or unwrap boto3 client creation.

        aioboto3 uses `async with session.client(...) as client:` but
        boto3 clients don't support context manager protocol. Detect
        `.client()` calls and convert to simple assignment.
        """
        # Check if this is a single-item `async with x.client(...) as var:`
        if len(node.items) == 1:
            item = node.items[0]
            ctx_expr = item.context_expr
            # Match pattern: something.client(...)
            if (
                isinstance(ctx_expr, ast.Call)
                and isinstance(ctx_expr.func, ast.Attribute)
                and ctx_expr.func.attr == "client"
                and item.optional_vars is not None
            ):
                # Convert to: var = something.client(...)
                assign = ast.Assign(
                    targets=[self.visit(item.optional_vars)],
                    value=self.visit(ctx_expr),
                    lineno=node.lineno,
                    col_offset=node.col_offset,
                )
                ast.fix_missing_locations(assign)
                body = [self.visit(stmt) for stmt in node.body]
                return [assign] + body  # type: ignore[return-value]

        new_node = ast.With(
            items=[self.visit(item) for item in node.items],
            body=[self.visit(stmt) for stmt in node.body],
        )
        return ast.copy_location(new_node, node)

    def visit_AsyncFor(self, node: ast.AsyncFor) -> ast.For:  # noqa: N802
        """Convert async for to for."""
        new_node = ast.For(
            target=self.visit(node.target),
            iter=self.visit(node.iter),
            body=[self.visit(stmt) for stmt in node.body],
            orelse=[self.visit(stmt) for stmt in node.orelse],
        )
        return ast.copy_location(new_node, node)

    def visit_ClassDef(self, node: ast.ClassDef) -> ast.ClassDef | None:  # noqa: N802
        """Rename or skip classes."""
        # Skip classes that should be imported from the async module
        if node.name in SKIP_CLASS_DEFINITIONS:
            return None

        if node.name in CLASS_RENAMES:
            node.name = CLASS_RENAMES[node.name]

        # Transform base classes (handle string annotations in bases)
        new_bases = []
        for base in node.bases:
            new_bases.append(self._transform_base_class(base))
        node.bases = new_bases

        # Filter out methods that should be removed (sync duplicates)
        # and rename _async_lock -> _sync_lock in field definitions
        new_body = []
        for item in node.body:
            # Check if this is a method to remove
            if isinstance(item, ast.FunctionDef | ast.AsyncFunctionDef):
                if item.name in REMOVE_METHODS:
                    continue
            # Check if this is an annotated assignment
            if isinstance(item, ast.AnnAssign) and isinstance(item.target, ast.Name):
                # Remove _sync_lock (duplicate after _async_lock is renamed)
                if item.target.id == "_sync_lock":
                    continue
                # Rename _async_lock -> _sync_lock
                if item.target.id == "_async_lock":
                    item.target.id = "_sync_lock"
            new_body.append(item)
        node.body = new_body

        # Continue visiting children
        self.generic_visit(node)
        return node

    def _transform_base_class(self, node: ast.AST) -> ast.AST:
        """Transform base class references."""
        if isinstance(node, ast.Name) and node.id in CLASS_RENAMES:
            node.id = CLASS_RENAMES[node.id]
        elif isinstance(node, ast.Subscript):
            # Handle Generic[T] style bases
            node.value = self._transform_base_class(node.value)
        return node

    def visit_Import(self, node: ast.Import) -> ast.Import:  # noqa: N802
        """Rewrite import statements."""
        for alias in node.names:
            if alias.name in IMPORT_MODULE_REWRITES:
                alias.name = IMPORT_MODULE_REWRITES[alias.name]
        return node

    def visit_ImportFrom(self, node: ast.ImportFrom) -> ast.ImportFrom:  # noqa: N802
        """Rewrite from ... import statements."""
        # Rewrite module path
        if node.module:
            # Check for exact module rewrites
            if node.module in IMPORT_MODULE_REWRITES:
                node.module = IMPORT_MODULE_REWRITES[node.module]

            # Check for relative import path rewrites
            module_key = (
                f".{node.module}" if node.level == 0 else "." * node.level + (node.module or "")
            )
            for old_path, new_path in IMPORT_PATH_REWRITES.items():
                if module_key.endswith(old_path.lstrip(".")):
                    # Replace the suffix
                    prefix = module_key[: -len(old_path.lstrip("."))]
                    new_module = prefix + new_path.lstrip(".")
                    node.module = new_module.lstrip(".")
                    break

        # Rewrite imported names
        for alias in node.names:
            if alias.name in IMPORT_NAME_REWRITES:
                old_name = alias.name
                alias.name = IMPORT_NAME_REWRITES[alias.name]
                # Also update asname if it was the same as name
                if alias.asname == old_name:
                    alias.asname = alias.name
            # Rewrite type names
            if alias.name in TYPE_REWRITES:
                alias.name = TYPE_REWRITES[alias.name]

        return node

    def visit_Name(self, node: ast.Name) -> ast.Name:  # noqa: N802
        """Rewrite class name references, module names, and decorator names."""
        if node.id in CLASS_RENAMES:
            node.id = CLASS_RENAMES[node.id]
        if node.id in TYPE_REWRITES:
            node.id = TYPE_REWRITES[node.id]
        # Also rewrite module names (e.g., aioboto3 -> boto3)
        if node.id in IMPORT_MODULE_REWRITES:
            node.id = IMPORT_MODULE_REWRITES[node.id]
        # Rewrite decorator names (e.g., asynccontextmanager -> contextmanager)
        if node.id in IMPORT_NAME_REWRITES:
            node.id = IMPORT_NAME_REWRITES[node.id]
        return node

    def visit_Attribute(self, node: ast.Attribute) -> ast.Attribute:  # noqa: N802
        """Rewrite attribute access for renamed modules and async methods."""
        # Rewrite __aenter__ -> __enter__, __aexit__ -> __exit__ for method calls
        if node.attr in METHOD_NAME_REWRITES:
            node.attr = METHOD_NAME_REWRITES[node.attr]

        # Rewrite _async_lock -> _sync_lock
        if node.attr in ATTRIBUTE_NAME_REWRITES:
            node.attr = ATTRIBUTE_NAME_REWRITES[node.attr]

        # Rewrite asyncio.Lock -> threading.Lock
        if (
            isinstance(node.value, ast.Name)
            and (node.value.id, node.attr) in ATTRIBUTE_ACCESS_REWRITES
        ):
            new_module, new_attr = ATTRIBUTE_ACCESS_REWRITES[(node.value.id, node.attr)]
            node.value.id = new_module
            node.attr = new_attr

        self.generic_visit(node)
        return node

    def visit_Constant(self, node: ast.Constant) -> ast.Constant:  # noqa: N802
        """Rewrite string annotations."""
        if isinstance(node.value, str):
            value = node.value
            # Rewrite class names in string annotations
            for old_name, new_name in CLASS_RENAMES.items():
                value = re.sub(rf"\b{old_name}\b", new_name, value)
            for old_name, new_name in TYPE_REWRITES.items():
                value = re.sub(rf"\b{old_name}\b", new_name, value)
            node.value = value
        return node

    def _transform_annotation(self, node: ast.AST | None) -> ast.AST | None:
        """Transform type annotations."""
        if node is None:
            return None
        return self.visit(node)

    def visit_FunctionDef(self, node: ast.FunctionDef) -> ast.FunctionDef:  # noqa: N802
        """Transform sync function definitions (for annotations)."""
        # Transform return annotation
        if node.returns:
            node.returns = self._transform_annotation(node.returns)

        # Transform argument annotations
        for arg in node.args.args:
            if arg.annotation:
                arg.annotation = self._transform_annotation(arg.annotation)

        self.generic_visit(node)
        return node

    def visit_AnnAssign(self, node: ast.AnnAssign) -> ast.AnnAssign:  # noqa: N802
        """Transform annotated assignments."""
        node.annotation = self._transform_annotation(node.annotation)
        self.generic_visit(node)
        return node

    def visit_Tuple(self, node: ast.Tuple) -> ast.Tuple:  # noqa: N802
        """Visit tuple elements (for type annotations like Callable[[...], ...])."""
        node.elts = [self.visit(elt) for elt in node.elts]
        return node

    def visit_List(self, node: ast.List) -> ast.List:  # noqa: N802
        """Visit list elements (for type annotations like Callable[[arg], ...])."""
        node.elts = [self.visit(elt) for elt in node.elts]
        return node

    def visit_Subscript(self, node: ast.Subscript) -> ast.AST:  # noqa: N802
        """Unwrap Awaitable[X] and Coroutine[Any, Any, X] to X."""
        # First, visit children to transform nested subscripts
        node.value = self.visit(node.value)
        node.slice = self.visit(node.slice)

        # Check if this is Awaitable[X] or Coroutine[..., X]
        if isinstance(node.value, ast.Name) and node.value.id in UNWRAP_SUBSCRIPTS:
            # For Awaitable[X], return X (already visited above)
            if node.value.id == "Awaitable":
                return node.slice
            # For Coroutine[Any, Any, X], return X (third element of tuple)
            if node.value.id == "Coroutine" and isinstance(node.slice, ast.Tuple):
                if len(node.slice.elts) >= 3:
                    return node.slice.elts[2]

        return node


def run_ruff_on_content(content: str, target_path: Path) -> str:
    """Run ruff check --fix and format on content, return formatted content.

    Raises FileNotFoundError if ruff is not installed.
    """
    import shutil
    import tempfile

    if shutil.which("ruff") is None:
        raise FileNotFoundError(
            "ruff is required for sync code generation. Install it with: pip install ruff"
        )

    # Write to a temp file with the same path structure for correct config resolution
    with tempfile.NamedTemporaryFile(
        mode="w", suffix=".py", dir=target_path.parent, delete=False
    ) as f:
        f.write(content)
        temp_path = Path(f.name)

    try:
        # Run ruff check --fix
        subprocess.run(
            ["ruff", "check", "--fix", str(temp_path)],
            capture_output=True,
            check=False,
        )

        # Run ruff format
        subprocess.run(
            ["ruff", "format", str(temp_path)],
            capture_output=True,
            check=False,
        )

        # Read back the formatted content
        return temp_path.read_text()
    finally:
        temp_path.unlink()


def transform_file(source_path: Path, target_path: Path) -> bool:
    """Transform a single file from async to sync.

    Returns True if file was changed, False otherwise.
    """
    source_code = source_path.read_text()

    # Parse AST
    tree = ast.parse(source_code)

    # Remove the original module docstring (we'll add our own header)
    if (
        tree.body
        and isinstance(tree.body[0], ast.Expr)
        and isinstance(tree.body[0].value, ast.Constant)
        and isinstance(tree.body[0].value.value, str)
    ):
        tree.body = tree.body[1:]

    # Transform
    transformer = AsyncToSyncTransformer(source_path.name)
    new_tree = transformer.visit(tree)

    # Fix missing locations
    ast.fix_missing_locations(new_tree)

    # Generate code
    new_code = ast.unparse(new_tree)

    # Add imports for skipped class definitions
    skip_imports = []
    for class_name, module in SKIP_CLASS_DEFINITIONS.items():
        if class_name in new_code:
            skip_imports.append(f"from {module} import {class_name}")

    # Add header
    relative_source = source_path.relative_to(SRC)
    header = GENERATED_HEADER.format(source_file=relative_source)
    skip_import_block = "\n".join(skip_imports) + "\n" if skip_imports else ""
    raw_code = header + skip_import_block + new_code + "\n"

    # Run ruff to format the code consistently
    target_path.parent.mkdir(parents=True, exist_ok=True)
    final_code = run_ruff_on_content(raw_code, target_path)

    # Check if changed
    if target_path.exists():
        existing = target_path.read_text()
        if existing == final_code:
            return False

    # Write
    target_path.write_text(final_code)
    return True


def main() -> int:
    """Run all transformations."""
    changed = []

    for source_name, target_name in SOURCE_TRANSFORMS:
        source_path = SRC / source_name
        target_path = SRC / target_name

        if not source_path.exists():
            print(f"WARNING: Source file not found: {source_path}")
            continue

        if transform_file(source_path, target_path):
            changed.append(target_name)
            print(f"Generated: {target_name}")
        else:
            print(f"Unchanged: {target_name}")

    if changed:
        print(f"\n{len(changed)} file(s) updated")
    else:
        print("\nAll files up to date")

    return 0


if __name__ == "__main__":
    sys.exit(main())
