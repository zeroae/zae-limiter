{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"zae-limiter","text":"<p>A rate limiting library backed by DynamoDB using the token bucket algorithm.</p> <p> </p>"},{"location":"#overview","title":"Overview","text":"<p>zae-limiter is designed for limiting LLM API calls where:</p> <ul> <li>Multiple limits are tracked per call (requests per minute, tokens per minute)</li> <li>Token counts are unknown until after the call completes</li> <li>Hierarchical limits exist (API key \u2192 project)</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Token Bucket Algorithm - Precise rate limiting with configurable burst capacity</li> <li>Multiple Limits - Track requests per minute, tokens per minute, etc. in a single call</li> <li>Hierarchical Entities - Two-level hierarchy (project \u2192 API keys) with cascade mode</li> <li>Atomic Transactions - Multi-key updates via DynamoDB TransactWriteItems</li> <li>Rollback on Exception - Automatic rollback if your code throws</li> <li>Stored Limits - Configure per-entity limits in DynamoDB</li> <li>Usage Analytics - Lambda aggregator for hourly/daily usage snapshots</li> <li>Async + Sync APIs - First-class async support with sync wrapper</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from zae_limiter import RateLimiter, Limit\n\nlimiter = RateLimiter(\n    table_name=\"rate_limits\",\n    region=\"us-east-1\",\n)\n\nasync with limiter.acquire(\n    entity_id=\"api-key-123\",\n    resource=\"gpt-4\",\n    limits=[\n        Limit.per_minute(\"rpm\", 100),       # 100 requests/minute\n        Limit.per_minute(\"tpm\", 10_000),    # 10k tokens/minute\n    ],\n    consume={\"rpm\": 1, \"tpm\": 500},  # estimate 500 tokens\n) as lease:\n    response = await call_llm()\n\n    # Reconcile actual token usage\n    actual_tokens = response.usage.total_tokens\n    await lease.adjust(tpm=actual_tokens - 500)\n</code></pre>"},{"location":"#why-dynamodb","title":"Why DynamoDB?","text":"<ul> <li>Serverless - No infrastructure to manage</li> <li>Global - Multi-region replication for low latency</li> <li>Scalable - Handles millions of requests per second</li> <li>Cost-effective - Pay per request, no idle costs</li> <li>Atomic - TransactWriteItems for multi-key consistency</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Installation and quick start guide</li> <li>User Guide - Detailed usage patterns</li> <li>API Reference - Complete API documentation</li> <li>Migrations - Schema migration strategy and versioning</li> </ul>"},{"location":"cli/","title":"CLI Reference","text":"<p>zae-limiter provides a command-line interface for managing infrastructure and deployments.</p>"},{"location":"cli/#installation","title":"Installation","text":"<p>The CLI is included with the package:</p> <pre><code>pip install zae-limiter\n</code></pre> <p>Verify installation:</p> <pre><code>zae-limiter --version\n</code></pre>"},{"location":"cli/#commands","title":"Commands","text":""},{"location":"cli/#deploy","title":"deploy","text":"<p>Deploy the CloudFormation stack with DynamoDB table and Lambda aggregator.</p> <pre><code>zae-limiter deploy [OPTIONS]\n</code></pre> <p>Options:</p> Option Description Default <code>--table-name</code> DynamoDB table name Required <code>--region</code> AWS region Required <code>--stack-name</code> CloudFormation stack name <code>zae-limiter-{table}</code> <code>--no-aggregator</code> Skip Lambda aggregator <code>false</code> <code>--log-retention-days</code> CloudWatch log retention (days) <code>14</code> <code>--pitr-recovery-days</code> Point-in-time recovery (days, 0=disabled) <code>0</code> <code>--endpoint-url</code> Custom AWS endpoint (LocalStack) None <p>Examples:</p> <pre><code># Basic deployment\nzae-limiter deploy --table-name rate_limits --region us-east-1\n\n# With custom settings\nzae-limiter deploy \\\n    --table-name prod_limits \\\n    --region us-west-2 \\\n    --stack-name my-rate-limiter \\\n    --log-retention-days 90 \\\n    --pitr-recovery-days 7\n\n# Deploy to LocalStack\nzae-limiter deploy \\\n    --table-name rate_limits \\\n    --endpoint-url http://localhost:4566 \\\n    --region us-east-1\n\n# Without Lambda aggregator\nzae-limiter deploy \\\n    --table-name rate_limits \\\n    --region us-east-1 \\\n    --no-aggregator\n</code></pre>"},{"location":"cli/#status","title":"status","text":"<p>Check the status of a deployed CloudFormation stack.</p> <pre><code>zae-limiter status [OPTIONS]\n</code></pre> <p>Options:</p> Option Description Default <code>--stack-name</code> CloudFormation stack name Required <code>--region</code> AWS region Required <code>--endpoint-url</code> Custom AWS endpoint None <p>Example:</p> <pre><code>zae-limiter status --stack-name zae-limiter-rate_limits --region us-east-1\n</code></pre> <p>Output:</p> <pre><code>Stack: zae-limiter-rate_limits\nStatus: CREATE_COMPLETE\nCreated: 2024-01-15 10:30:00\n\nResources:\n  - RateLimitsTable (AWS::DynamoDB::Table): CREATE_COMPLETE\n  - AggregatorFunction (AWS::Lambda::Function): CREATE_COMPLETE\n  - AggregatorRole (AWS::IAM::Role): CREATE_COMPLETE\n\nOutputs:\n  - TableName: rate_limits\n  - TableArn: arn:aws:dynamodb:us-east-1:123456789:table/rate_limits\n</code></pre>"},{"location":"cli/#delete","title":"delete","text":"<p>Delete a CloudFormation stack and all its resources.</p> <pre><code>zae-limiter delete [OPTIONS]\n</code></pre> <p>Options:</p> Option Description Default <code>--stack-name</code> CloudFormation stack name Required <code>--region</code> AWS region Required <code>--yes</code> Skip confirmation prompt <code>false</code> <code>--endpoint-url</code> Custom AWS endpoint None <p>Example:</p> <pre><code># With confirmation\nzae-limiter delete --stack-name zae-limiter-rate_limits --region us-east-1\n\n# Skip confirmation\nzae-limiter delete --stack-name zae-limiter-rate_limits --region us-east-1 --yes\n</code></pre> <p>Data Loss</p> <p>Deleting a stack removes the DynamoDB table and all its data. This action cannot be undone.</p>"},{"location":"cli/#cfn-template","title":"cfn-template","text":"<p>Export the CloudFormation template to stdout.</p> <pre><code>zae-limiter cfn-template [OPTIONS]\n</code></pre> <p>Options:</p> Option Description Default <code>--format</code> Output format (yaml, json) <code>yaml</code> <p>Examples:</p> <pre><code># Export YAML template\nzae-limiter cfn-template &gt; template.yaml\n\n# Export JSON template\nzae-limiter cfn-template --format json &gt; template.json\n\n# View template\nzae-limiter cfn-template | less\n</code></pre>"},{"location":"cli/#lambda-export","title":"lambda-export","text":"<p>Export the Lambda deployment package.</p> <pre><code>zae-limiter lambda-export [OPTIONS]\n</code></pre> <p>Options:</p> Option Description Default <code>--output</code> Output file path Required (unless <code>--info</code>) <code>--info</code> Show package info without building <code>false</code> <p>Examples:</p> <pre><code># Export Lambda package\nzae-limiter lambda-export --output lambda.zip\n\n# Show package info\nzae-limiter lambda-export --info\n</code></pre> <p>Info output:</p> <pre><code>Lambda Package Info:\n  Handler: zae_limiter.aggregator.handler.lambda_handler\n  Runtime: python3.12\n  Estimated size: ~30KB\n  Dependencies: boto3 (provided by Lambda runtime)\n</code></pre>"},{"location":"cli/#version","title":"version","text":"<p>Show the installed version.</p> <pre><code>zae-limiter version\n</code></pre> <p>Output:</p> <pre><code>zae-limiter 0.1.0\n</code></pre>"},{"location":"cli/#check","title":"check","text":"<p>Check schema compatibility with a deployed table.</p> <pre><code>zae-limiter check [OPTIONS]\n</code></pre> <p>Options:</p> Option Description Default <code>--table-name</code> DynamoDB table name Required <code>--region</code> AWS region Required <code>--endpoint-url</code> Custom AWS endpoint None <p>Example:</p> <pre><code>zae-limiter check --table-name rate_limits --region us-east-1\n</code></pre> <p>Output:</p> <pre><code>Schema version: 1.0.0\nLibrary version: 1.0.0\nStatus: Compatible\n</code></pre>"},{"location":"cli/#upgrade","title":"upgrade","text":"<p>Upgrade a table schema to the latest version.</p> <pre><code>zae-limiter upgrade [OPTIONS]\n</code></pre> <p>Options:</p> Option Description Default <code>--table-name</code> DynamoDB table name Required <code>--region</code> AWS region Required <code>--endpoint-url</code> Custom AWS endpoint None <code>--dry-run</code> Show changes without applying <code>false</code> <p>Example:</p> <pre><code># Preview changes\nzae-limiter upgrade --table-name rate_limits --region us-east-1 --dry-run\n\n# Apply upgrade\nzae-limiter upgrade --table-name rate_limits --region us-east-1\n</code></pre>"},{"location":"cli/#environment-variables","title":"Environment Variables","text":"<p>The CLI respects standard AWS environment variables:</p> Variable Description <code>AWS_ACCESS_KEY_ID</code> AWS access key <code>AWS_SECRET_ACCESS_KEY</code> AWS secret key <code>AWS_SESSION_TOKEN</code> AWS session token <code>AWS_DEFAULT_REGION</code> Default AWS region <code>AWS_PROFILE</code> AWS profile name <code>AWS_ENDPOINT_URL</code> Custom endpoint URL"},{"location":"cli/#exit-codes","title":"Exit Codes","text":"Code Description <code>0</code> Success <code>1</code> General error <code>2</code> Invalid arguments <code>3</code> AWS API error <code>4</code> Stack not found"},{"location":"cli/#next-steps","title":"Next Steps","text":"<ul> <li>Deployment - Deployment guide</li> <li>LocalStack - Local development</li> <li>API Reference - Python API documentation</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you install zae-limiter and set up rate limiting in your application.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"pipuvpoetry <pre><code>pip install zae-limiter\n</code></pre> <pre><code>uv pip install zae-limiter\n</code></pre> <pre><code>poetry add zae-limiter\n</code></pre>"},{"location":"getting-started/#deploy-infrastructure","title":"Deploy Infrastructure","text":"<p>Before using zae-limiter, you need to deploy the DynamoDB table and optional Lambda aggregator.</p>"},{"location":"getting-started/#option-1-cli-recommended","title":"Option 1: CLI (Recommended)","text":"<pre><code>zae-limiter deploy --table-name rate_limits --region us-east-1\n</code></pre> <p>This creates a CloudFormation stack with:</p> <ul> <li>DynamoDB table with streams enabled</li> <li>Lambda function for usage aggregation</li> <li>Required IAM roles and permissions</li> </ul>"},{"location":"getting-started/#option-2-export-template","title":"Option 2: Export Template","text":"<pre><code># Export CloudFormation template\nzae-limiter cfn-template &gt; template.yaml\n\n# Deploy with AWS CLI\naws cloudformation deploy \\\n    --template-file template.yaml \\\n    --stack-name zae-limiter \\\n    --capabilities CAPABILITY_NAMED_IAM\n</code></pre>"},{"location":"getting-started/#option-3-auto-create-in-code-development","title":"Option 3: Auto-Create in Code (Development)","text":"<pre><code>from zae_limiter import RateLimiter\n\nlimiter = RateLimiter(\n    table_name=\"rate_limits\",\n    region=\"us-east-1\",\n    create_stack=True,  # Auto-creates CloudFormation stack\n)\n</code></pre> <p>Production Use</p> <p>Auto-creation is convenient for development but not recommended for production. Use the CLI or CloudFormation for production deployments.</p>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/#async-api-recommended","title":"Async API (Recommended)","text":"<pre><code>from zae_limiter import RateLimiter, Limit, RateLimitExceeded\n\nlimiter = RateLimiter(\n    table_name=\"rate_limits\",\n    region=\"us-east-1\",\n)\n\ntry:\n    async with limiter.acquire(\n        entity_id=\"user-123\",\n        resource=\"api\",\n        limits=[Limit.per_minute(\"requests\", 100)],\n        consume={\"requests\": 1},\n    ) as lease:\n        await do_work()\nexcept RateLimitExceeded as e:\n    print(f\"Rate limited! Retry after {e.retry_after_seconds:.1f}s\")\n</code></pre>"},{"location":"getting-started/#sync-api","title":"Sync API","text":"<pre><code>from zae_limiter import SyncRateLimiter, Limit\n\nlimiter = SyncRateLimiter(table_name=\"rate_limits\")\n\nwith limiter.acquire(\n    entity_id=\"user-123\",\n    resource=\"api\",\n    limits=[Limit.per_minute(\"requests\", 100)],\n    consume={\"requests\": 1},\n) as lease:\n    response = call_api()\n</code></pre>"},{"location":"getting-started/#understanding-limits","title":"Understanding Limits","text":"<p>A <code>Limit</code> defines a rate limit using the token bucket algorithm:</p> <pre><code># 100 requests per minute\nLimit.per_minute(\"rpm\", 100)\n\n# 10,000 tokens per minute with 15,000 burst capacity\nLimit.per_minute(\"tpm\", 10_000, burst=15_000)\n\n# 1,000 requests per hour\nLimit.per_hour(\"rph\", 1_000)\n\n# Custom: 50 requests per 30 seconds\nLimit.custom(\"requests\", capacity=50, refill_period_seconds=30)\n</code></pre> Parameter Description <code>name</code> Unique identifier (e.g., \"rpm\", \"tpm\") <code>capacity</code> Tokens that refill per period (sustained rate) <code>burst</code> Maximum bucket size (defaults to capacity)"},{"location":"getting-started/#handling-rate-limit-errors","title":"Handling Rate Limit Errors","text":"<p>When a rate limit is exceeded, <code>RateLimitExceeded</code> is raised with full details:</p> <pre><code>from zae_limiter import RateLimitExceeded\n\ntry:\n    async with limiter.acquire(...):\n        await do_work()\nexcept RateLimitExceeded as e:\n    # Get retry delay\n    print(f\"Retry after: {e.retry_after_seconds}s\")\n\n    # For HTTP responses\n    return JSONResponse(\n        status_code=429,\n        content=e.as_dict(),\n        headers={\"Retry-After\": e.retry_after_header},\n    )\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Usage - More usage patterns</li> <li>Hierarchical Limits - Parent/child entities</li> <li>LLM Integration - Token estimation and reconciliation</li> <li>CLI Reference - Command-line interface</li> </ul>"},{"location":"migrations/","title":"Migrations","text":"<p>This guide covers managing schema migrations for zae-limiter infrastructure.</p>"},{"location":"migrations/#overview","title":"Overview","text":"<p>Schema migrations handle changes to the DynamoDB table structure when upgrading between major versions of zae-limiter. The migration framework provides:</p> <ul> <li>Version tracking - Infrastructure version stored in DynamoDB</li> <li>Compatibility checking - Automatic client/infrastructure compatibility validation</li> <li>Migration registry - Ordered list of migrations between versions</li> <li>Rollback support - Optional rollback functions for reversible changes</li> </ul>"},{"location":"migrations/#when-migrations-are-needed","title":"When Migrations Are Needed","text":"Change Type Migration Required? Version Bump Add optional attribute No Patch (x.x.1) Add new index (GSI) Yes Minor (x.1.0) Change key structure Yes Major (1.0.0) Remove attribute Yes Major (1.0.0) Change attribute type Yes Major (1.0.0)"},{"location":"migrations/#version-compatibility","title":"Version Compatibility","text":"<p>zae-limiter uses semantic versioning with specific compatibility rules.</p>"},{"location":"migrations/#compatibility-rules","title":"Compatibility Rules","text":"<pre><code>Client 1.x.x + Schema 1.x.x = Compatible\nClient 2.x.x + Schema 1.x.x = Incompatible (migration required)\nClient 1.2.0 + Min Client 1.3.0 = Incompatible (upgrade client)\n</code></pre> <p>Major version mismatch: Always incompatible. Schema migration required before the client can operate.</p> <p>Minor/patch version mismatch: Compatible. Client and infrastructure can operate together.</p> <p>Minimum client version: Infrastructure can require a minimum client version. Older clients are rejected.</p>"},{"location":"migrations/#checking-compatibility","title":"Checking Compatibility","text":"<p>Use the CLI to check compatibility without modifying anything:</p> <pre><code># Check current compatibility status\nzae-limiter check --table-name rate_limits --region us-east-1\n</code></pre> <p>Output:</p> <pre><code>Compatibility Check\n====================\n\nClient:      1.2.0\nSchema:      1.0.0\nLambda:      1.1.0\n\nResult: COMPATIBLE (update available)\n\nLambda update available: 1.1.0 -&gt; 1.2.0\n\nRun 'zae-limiter upgrade' to update.\n</code></pre>"},{"location":"migrations/#viewing-version-information","title":"Viewing Version Information","text":"<pre><code># Show detailed version information\nzae-limiter version --table-name rate_limits --region us-east-1\n</code></pre> <p>Output:</p> <pre><code>zae-limiter Infrastructure Version\n====================================\n\nClient Version:     1.2.0\nSchema Version:     1.0.0\n\nInfra Schema:       1.0.0\nLambda Version:     1.1.0\nMin Client Version: 0.0.0\n\nStatus: COMPATIBLE (Lambda update available)\n\n  Lambda update available: 1.1.0 -&gt; 1.2.0\n\nRun 'zae-limiter upgrade' to update Lambda.\n</code></pre>"},{"location":"migrations/#upgrading-infrastructure","title":"Upgrading Infrastructure","text":"<p>For minor updates (Lambda code, no schema changes):</p> <pre><code># Upgrade Lambda to match client version\nzae-limiter upgrade --table-name rate_limits --region us-east-1\n</code></pre> <p>For major version upgrades requiring schema migration, see Sample Migration: v2.0.0.</p>"},{"location":"migrations/#schema-modification-approaches","title":"Schema Modification Approaches","text":"<p>When modifying the DynamoDB schema, prefer solutions that preserve backward compatibility.</p>"},{"location":"migrations/#non-breaking-changes-preferred","title":"Non-Breaking Changes (Preferred)","text":"<p>These changes don't require migrations:</p> <p>Adding optional attributes: <pre><code># Old code works - attribute simply missing\nitem = {\"PK\": \"ENTITY#123\", \"SK\": \"#META\", \"name\": \"test\"}\n\n# New code adds optional attribute\nitem = {\"PK\": \"ENTITY#123\", \"SK\": \"#META\", \"name\": \"test\", \"tags\": [\"prod\"]}\n</code></pre></p> <p>Using <code>if_not_exists()</code> for new nested structures: <pre><code># Initialize nested map only if missing\nupdate_expression = \"SET #data.#metrics = if_not_exists(#data.#metrics, :empty_map)\"\n</code></pre></p> <p>Adding conditional logic for missing attributes: <pre><code># Handle missing attribute gracefully\nmetrics = item.get(\"data\", {}).get(\"metrics\", {})\nrequest_count = metrics.get(\"requests\", 0)\n</code></pre></p>"},{"location":"migrations/#breaking-changes-major-version","title":"Breaking Changes (Major Version)","text":"<p>These changes require migrations and major version bumps:</p> <ul> <li>Changing partition or sort key structure</li> <li>Removing required attributes</li> <li>Changing attribute data types</li> <li>Renaming attributes</li> <li>Restructuring nested data</li> </ul>"},{"location":"migrations/#dynamodb-specific-considerations","title":"DynamoDB-Specific Considerations","text":"<p>GSI Changes:</p> <ul> <li>Adding a GSI: Can be done without migration (CloudFormation update)</li> <li>Removing a GSI: Requires ensuring no code depends on it</li> <li>Changing GSI keys: Requires data migration</li> </ul> <p>Key Pattern Changes:</p> <pre><code># v1.0.0 pattern\nPK = f\"ENTITY#{entity_id}\"\nSK = f\"#BUCKET#{resource}#{limit_name}\"\n\n# v2.0.0 pattern (breaking change!)\nPK = f\"ENT#{entity_id}\"  # Changed prefix\nSK = f\"BKT#{resource}#{limit_name}\"  # Changed prefix\n</code></pre> <p>Key pattern changes require migrating all existing data.</p>"},{"location":"migrations/#creating-a-migration","title":"Creating a Migration","text":""},{"location":"migrations/#migration-file-structure","title":"Migration File Structure","text":"<p>Create a new file in <code>src/zae_limiter/migrations/</code>:</p> <pre><code># src/zae_limiter/migrations/v1_1_0.py\n\"\"\"\nMigration: v1.1.0 (Add metrics tracking)\n\nThis migration adds a metrics attribute to entity metadata\nfor tracking request statistics.\n\nChanges:\n- Add 'metrics' map to entity #META records\n- Initialize with empty counters\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom . import Migration, register_migration\n\nif TYPE_CHECKING:\n    from ..repository import Repository\n\n\nasync def migrate_v1_1_0(repository: Repository) -&gt; None:\n    \"\"\"\n    Add metrics attribute to all entity metadata records.\n\n    This is a forward-only migration that initializes the\n    metrics structure for existing entities.\n    \"\"\"\n    # Query all entity metadata records\n    # Update each to add metrics if missing\n    # Use conditional updates to be idempotent\n    pass\n\n\nasync def rollback_v1_1_0(repository: Repository) -&gt; None:\n    \"\"\"\n    Remove metrics attribute from entity metadata.\n\n    Note: This loses all collected metrics data.\n    \"\"\"\n    # Remove metrics attribute from all entities\n    pass\n\n\n# Register the migration\nregister_migration(\n    Migration(\n        version=\"1.1.0\",\n        description=\"Add metrics tracking to entities\",\n        reversible=True,\n        migrate=migrate_v1_1_0,\n        rollback=rollback_v1_1_0,\n    )\n)\n</code></pre>"},{"location":"migrations/#migration-protocol","title":"Migration Protocol","text":"<p>Migration functions must follow this protocol:</p> <pre><code>async def __call__(self, repository: Repository) -&gt; None:\n    \"\"\"Execute the migration.\"\"\"\n    ...\n</code></pre> <p>Key requirements:</p> <ol> <li>Async: All migrations are async functions</li> <li>Repository parameter: Receives a configured Repository instance</li> <li>Idempotent: Safe to run multiple times (use conditional updates)</li> <li>Atomic where possible: Use transactions for related changes</li> </ol>"},{"location":"migrations/#registering-migrations","title":"Registering Migrations","text":"<p>Migrations are auto-registered when imported. Ensure your migration module is imported in <code>migrations/__init__.py</code>:</p> <pre><code># src/zae_limiter/migrations/__init__.py\n\n# ... existing code ...\n\n# Import built-in migrations to register them\nfrom . import v1_0_0 as _v1_0_0  # noqa: F401, E402\nfrom . import v1_1_0 as _v1_1_0  # noqa: F401, E402  # Add new migration\n</code></pre>"},{"location":"migrations/#updating-schema-version","title":"Updating Schema Version","text":"<p>After adding a migration, update the current schema version:</p> <pre><code># src/zae_limiter/version.py\n\n# Current schema version - increment when schema changes\nCURRENT_SCHEMA_VERSION = \"1.1.0\"  # Updated from \"1.0.0\"\n</code></pre>"},{"location":"migrations/#validating-migrations","title":"Validating Migrations","text":""},{"location":"migrations/#unit-testing-with-moto","title":"Unit Testing with Moto","text":"<p>Test migrations using moto for fast, isolated tests:</p> <pre><code># tests/test_migrations.py\nimport pytest\nfrom moto import mock_aws\n\nfrom zae_limiter.migrations import get_migrations_between, apply_migrations\nfrom zae_limiter.repository import Repository\n\n\n@pytest.fixture\ndef mock_dynamodb():\n    with mock_aws():\n        # Create table and seed test data\n        yield\n\n\n@pytest.mark.asyncio\nasync def test_migration_v1_1_0(mock_dynamodb):\n    \"\"\"Test v1.1.0 migration adds metrics to entities.\"\"\"\n    repo = Repository(\"test_table\", \"us-east-1\", None)\n\n    # Create test entity without metrics\n    await repo.create_entity(entity_id=\"test-1\", name=\"Test Entity\")\n\n    # Apply migration\n    applied = await apply_migrations(repo, \"1.0.0\", \"1.1.0\")\n\n    assert applied == [\"1.1.0\"]\n\n    # Verify metrics added - use raw DynamoDB query since Entity\n    # dataclass won't have the new 'metrics' field until code is updated\n    client = await repo._get_client()\n    response = await client.get_item(\n        TableName=repo.table_name,\n        Key={\"PK\": {\"S\": \"ENTITY#test-1\"}, \"SK\": {\"S\": \"#META\"}},\n    )\n    item = response[\"Item\"]\n    assert \"metrics\" in item[\"data\"][\"M\"]\n    assert item[\"data\"][\"M\"][\"metrics\"][\"M\"][\"requests\"][\"N\"] == \"0\"\n\n\n@pytest.mark.asyncio\nasync def test_migration_idempotent(mock_dynamodb):\n    \"\"\"Test migration can be safely run multiple times.\"\"\"\n    repo = Repository(\"test_table\", \"us-east-1\", None)\n\n    # Create test entity\n    await repo.create_entity(entity_id=\"test-1\", name=\"Test Entity\")\n\n    # Run migration twice\n    await apply_migrations(repo, \"1.0.0\", \"1.1.0\")\n    await apply_migrations(repo, \"1.0.0\", \"1.1.0\")  # Should not fail\n\n    # Verify single application via raw DynamoDB query\n    client = await repo._get_client()\n    response = await client.get_item(\n        TableName=repo.table_name,\n        Key={\"PK\": {\"S\": \"ENTITY#test-1\"}, \"SK\": {\"S\": \"#META\"}},\n    )\n    item = response[\"Item\"]\n    assert item[\"data\"][\"M\"][\"metrics\"][\"M\"][\"requests\"][\"N\"] == \"0\"\n</code></pre>"},{"location":"migrations/#integration-testing-with-localstack","title":"Integration Testing with LocalStack","text":"<p>Test migrations against real AWS-compatible infrastructure:</p> <pre><code># tests/test_migrations_integration.py\nimport os\nimport pytest\n\n# Skip if LocalStack not available\npytestmark = pytest.mark.skipif(\n    not os.environ.get(\"AWS_ENDPOINT_URL\"),\n    reason=\"LocalStack not available\"\n)\n\n\n@pytest.mark.integration\n@pytest.mark.asyncio\nasync def test_migration_with_localstack():\n    \"\"\"Test migration against LocalStack.\"\"\"\n    endpoint_url = os.environ[\"AWS_ENDPOINT_URL\"]\n\n    repo = Repository(\n        \"test_migrations\",\n        \"us-east-1\",\n        endpoint_url,\n    )\n\n    # Deploy infrastructure\n    # ... create table with CloudFormation ...\n\n    # Seed test data\n    # ... create entities ...\n\n    # Apply migration\n    applied = await apply_migrations(repo, \"1.0.0\", \"1.1.0\")\n\n    # Verify changes persisted\n    # ... assertions ...\n</code></pre> <p>Run integration tests:</p> <pre><code># Start LocalStack\ndocker run -d -p 4566:4566 \\\n  -e SERVICES=dynamodb,dynamodbstreams,lambda,cloudformation \\\n  localstack/localstack\n\n# Run integration tests\nAWS_ENDPOINT_URL=http://localhost:4566 pytest -m integration -v\n</code></pre>"},{"location":"migrations/#production-validation-checklist","title":"Production Validation Checklist","text":"<p>Before running migrations in production:</p> <ul> <li>[ ] Backup: Enable Point-in-Time Recovery (PITR) or create on-demand backup</li> <li>[ ] Test: Run migration against production data copy</li> <li>[ ] Monitor: Set up CloudWatch alarms for errors</li> <li>[ ] Rollback plan: Document rollback procedure</li> <li>[ ] Maintenance window: Schedule during low-traffic period</li> <li>[ ] Communication: Notify stakeholders of potential downtime</li> </ul> <pre><code># Create on-demand backup before migration\naws dynamodb create-backup \\\n  --table-name rate_limits \\\n  --backup-name \"pre-migration-$(date +%Y%m%d)\"\n\n# Verify PITR is enabled\naws dynamodb describe-continuous-backups \\\n  --table-name rate_limits\n</code></pre>"},{"location":"migrations/#rollback-strategies","title":"Rollback Strategies","text":""},{"location":"migrations/#reversible-migrations","title":"Reversible Migrations","text":"<p>For migrations that can be safely undone:</p> <pre><code>register_migration(\n    Migration(\n        version=\"1.1.0\",\n        description=\"Add metrics tracking\",\n        reversible=True,  # Can be rolled back\n        migrate=migrate_v1_1_0,\n        rollback=rollback_v1_1_0,  # Rollback function\n    )\n)\n</code></pre> <p>Rollback removes or reverts the changes:</p> <pre><code>async def rollback_v1_1_0(repository: Repository) -&gt; None:\n    \"\"\"Remove metrics attribute from all entities.\"\"\"\n    # Implementation to remove metrics attribute\n    pass\n</code></pre>"},{"location":"migrations/#forward-only-migrations","title":"Forward-Only Migrations","text":"<p>Some migrations cannot be reversed:</p> <pre><code>register_migration(\n    Migration(\n        version=\"2.0.0\",\n        description=\"Restructure key patterns\",\n        reversible=False,  # Cannot be rolled back\n        migrate=migrate_v2_0_0,\n        rollback=None,  # No rollback function\n    )\n)\n</code></pre> <p>Forward-only migrations typically involve:</p> <ul> <li>Data transformation with information loss</li> <li>Key structure changes</li> <li>Removing deprecated attributes</li> </ul>"},{"location":"migrations/#emergency-rollback-procedures","title":"Emergency Rollback Procedures","text":"<p>If a migration fails or causes issues:</p> <p>1. Stop the bleeding: <pre><code># Revert to previous client version\npip install zae-limiter==1.0.0\n</code></pre></p> <p>2. Restore from backup (if needed): <pre><code># Restore from PITR\naws dynamodb restore-table-to-point-in-time \\\n  --source-table-name rate_limits \\\n  --target-table-name rate_limits_restored \\\n  --restore-date-time \"2024-01-15T10:00:00Z\"\n</code></pre></p> <p>3. Run rollback (if reversible): <pre><code>from zae_limiter.migrations import get_migrations\nfrom zae_limiter.repository import Repository\n\nasync def emergency_rollback():\n    repo = Repository(\"rate_limits\", \"us-east-1\", None)\n\n    migrations = get_migrations()\n    target_migration = next(m for m in migrations if m.version == \"1.1.0\")\n\n    if target_migration.reversible and target_migration.rollback:\n        await target_migration.rollback(repo)\n        print(\"Rollback complete\")\n    else:\n        print(\"Migration is not reversible - restore from backup\")\n</code></pre></p> <p>4. Update version record: <pre><code>await repo.set_version_record(\n    schema_version=\"1.0.0\",  # Reverted version\n    lambda_version=\"1.0.0\",\n    updated_by=\"emergency_rollback\",\n)\n</code></pre></p>"},{"location":"migrations/#sample-migration-v200","title":"Sample Migration: v2.0.0","text":"<p>This example demonstrates a complete migration scenario for a hypothetical v2.0.0 release that adds a new Global Secondary Index for querying entities by creation date.</p>"},{"location":"migrations/#scenario","title":"Scenario","text":"<p>Goal: Add ability to query entities by creation timestamp for audit purposes.</p> <p>Changes: 1. Add <code>created_at</code> attribute to entity metadata 2. Add GSI3 for querying by creation date 3. Backfill <code>created_at</code> for existing entities</p>"},{"location":"migrations/#migration-implementation","title":"Migration Implementation","text":"<pre><code># src/zae_limiter/migrations/v2_0_0.py\n\"\"\"\nMigration: v2.0.0 (Add creation timestamp tracking)\n\nThis migration adds a created_at timestamp to all entities and\ncreates a new GSI for querying entities by creation date.\n\nSchema changes:\n- Add 'created_at' attribute to entity #META records\n- Add GSI3: GSI3PK=CREATED#{YYYY-MM}, GSI3SK=ENTITY#{id}\n\nBreaking changes:\n- Requires CloudFormation stack update for GSI3\n- All queries using GSI3 require v2.0.0+ client\n\nRollback:\n- This migration is NOT reversible (GSI removal loses query capability)\n- Restore from backup if rollback needed\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nfrom datetime import datetime, timezone\nfrom typing import TYPE_CHECKING\n\nfrom . import Migration, register_migration\n\nif TYPE_CHECKING:\n    from ..repository import Repository\n\n\nasync def migrate_v2_0_0(repository: Repository) -&gt; None:\n    \"\"\"\n    Add created_at timestamp to all existing entities.\n\n    Note: GSI3 must be added via CloudFormation update before\n    running this migration. The migration only backfills data.\n\n    Steps:\n    1. Scan all entity metadata records\n    2. Add created_at if missing (set to migration timestamp)\n    3. Add GSI3 keys for index population\n    \"\"\"\n    migration_time = datetime.now(timezone.utc).isoformat()\n    migration_month = datetime.now(timezone.utc).strftime(\"%Y-%m\")\n\n    # Get DynamoDB client\n    client = await repository._get_client()\n\n    # Scan for all entity metadata records\n    paginator = client.get_paginator('scan')\n\n    async for page in paginator.paginate(\n        TableName=repository.table_name,\n        FilterExpression=\"begins_with(SK, :meta)\",\n        ExpressionAttributeValues={\":meta\": {\"S\": \"#META\"}},\n    ):\n        items = page.get(\"Items\", [])\n\n        # Process in batches of 25 (DynamoDB limit)\n        for i in range(0, len(items), 25):\n            batch = items[i:i + 25]\n\n            # Build batch update\n            update_requests = []\n            for item in batch:\n                pk = item[\"PK\"][\"S\"]\n                sk = item[\"SK\"][\"S\"]\n\n                # Use conditional update - only if created_at missing\n                update_requests.append({\n                    \"Update\": {\n                        \"TableName\": repository.table_name,\n                        \"Key\": {\"PK\": {\"S\": pk}, \"SK\": {\"S\": sk}},\n                        \"UpdateExpression\": (\n                            \"SET #created = if_not_exists(#created, :ts), \"\n                            \"GSI3PK = if_not_exists(GSI3PK, :gsi3pk), \"\n                            \"GSI3SK = if_not_exists(GSI3SK, :gsi3sk)\"\n                        ),\n                        \"ExpressionAttributeNames\": {\n                            \"#created\": \"created_at\",\n                        },\n                        \"ExpressionAttributeValues\": {\n                            \":ts\": {\"S\": migration_time},\n                            \":gsi3pk\": {\"S\": f\"CREATED#{migration_month}\"},\n                            \":gsi3sk\": {\"S\": pk},\n                        },\n                    }\n                })\n\n            # Execute batch (transactions limited to 100 items)\n            if update_requests:\n                await client.transact_write_items(\n                    TransactItems=update_requests\n                )\n\n        # Rate limiting to avoid throttling\n        await asyncio.sleep(0.1)\n\n    # Update version record\n    await repository.set_version_record(\n        schema_version=\"2.0.0\",\n        client_min_version=\"2.0.0\",  # Require v2.0.0+ clients\n        updated_by=\"migration:v2.0.0\",\n    )\n\n\n# Register the migration\nregister_migration(\n    Migration(\n        version=\"2.0.0\",\n        description=\"Add creation timestamp tracking with GSI3\",\n        reversible=False,  # GSI changes are not easily reversible\n        migrate=migrate_v2_0_0,\n        rollback=None,\n    )\n)\n</code></pre>"},{"location":"migrations/#cloudformation-update","title":"CloudFormation Update","text":"<p>The GSI must be added before running the migration:</p> <pre><code># Addition to cfn_template.yaml\nResources:\n  RateLimitsTable:\n    Type: AWS::DynamoDB::Table\n    Properties:\n      # ... existing properties ...\n      GlobalSecondaryIndexes:\n        # ... existing GSIs ...\n        - IndexName: GSI3\n          KeySchema:\n            - AttributeName: GSI3PK\n              KeyType: HASH\n            - AttributeName: GSI3SK\n              KeyType: RANGE\n          Projection:\n            ProjectionType: ALL\n      AttributeDefinitions:\n        # ... existing attributes ...\n        - AttributeName: GSI3PK\n          AttributeType: S\n        - AttributeName: GSI3SK\n          AttributeType: S\n</code></pre>"},{"location":"migrations/#running-the-migration","title":"Running the Migration","text":"<pre><code># 1. Create backup\naws dynamodb create-backup \\\n  --table-name rate_limits \\\n  --backup-name \"pre-v2-migration-$(date +%Y%m%d)\"\n\n# 2. Update CloudFormation stack (adds GSI3)\naws cloudformation update-stack \\\n  --stack-name zae-limiter-rate_limits \\\n  --template-body file://updated-template.yaml \\\n  --capabilities CAPABILITY_NAMED_IAM\n\n# 3. Wait for GSI to be active\naws dynamodb wait table-exists --table-name rate_limits\n\n# 4. Install new client version\npip install zae-limiter==2.0.0\n\n# 5. Run migration (via upgrade command or programmatically)\npython -c \"\nimport asyncio\nfrom zae_limiter.migrations import apply_migrations\nfrom zae_limiter.repository import Repository\n\nasync def run():\n    repo = Repository('rate_limits', 'us-east-1', None)\n    applied = await apply_migrations(repo, '1.0.0', '2.0.0')\n    print(f'Applied migrations: {applied}')\n    await repo.close()\n\nasyncio.run(run())\n\"\n\n# 6. Verify migration\nzae-limiter version --table-name rate_limits --region us-east-1\n</code></pre>"},{"location":"migrations/#testing-the-migration","title":"Testing the Migration","text":"<pre><code>@pytest.mark.asyncio\nasync def test_v2_migration_adds_created_at(mock_dynamodb):\n    \"\"\"Test v2.0.0 migration adds created_at to entities.\"\"\"\n    repo = Repository(\"test_table\", \"us-east-1\", None)\n\n    # Create entities without created_at (v1 schema)\n    await repo.create_entity(entity_id=\"entity-1\", name=\"Test 1\")\n    await repo.create_entity(entity_id=\"entity-2\", name=\"Test 2\")\n\n    # Verify no created_at before migration\n    entity = await repo.get_entity(\"entity-1\")\n    assert entity.created_at is None\n\n    # Apply migration\n    applied = await apply_migrations(repo, \"1.0.0\", \"2.0.0\")\n    assert applied == [\"2.0.0\"]\n\n    # Verify created_at added - check raw DynamoDB for GSI3 keys\n    # (Entity dataclass has created_at, but GSI3PK/GSI3SK are schema-level)\n    client = await repo._get_client()\n    response = await client.get_item(\n        TableName=repo.table_name,\n        Key={\"PK\": {\"S\": \"ENTITY#entity-1\"}, \"SK\": {\"S\": \"#META\"}},\n    )\n    item = response[\"Item\"]\n    assert \"created_at\" in item\n    assert item[\"created_at\"][\"S\"].startswith(\"20\")  # Valid ISO timestamp\n    assert \"GSI3PK\" in item  # GSI key was added\n    assert item[\"GSI3PK\"][\"S\"].startswith(\"CREATED#\")\n\n\n@pytest.mark.asyncio\nasync def test_v2_migration_idempotent(mock_dynamodb):\n    \"\"\"Test v2.0.0 migration is idempotent.\"\"\"\n    repo = Repository(\"test_table\", \"us-east-1\", None)\n\n    # Create entity with created_at already set\n    # (simulating an entity created after v2.0.0 code deployed)\n    original_time = \"2024-01-01T00:00:00Z\"\n    client = await repo._get_client()\n    await client.put_item(\n        TableName=repo.table_name,\n        Item={\n            \"PK\": {\"S\": \"ENTITY#entity-1\"},\n            \"SK\": {\"S\": \"#META\"},\n            \"data\": {\"M\": {\"name\": {\"S\": \"Test\"}}},\n            \"created_at\": {\"S\": original_time},\n            \"GSI3PK\": {\"S\": \"CREATED#2024-01\"},\n            \"GSI3SK\": {\"S\": \"ENTITY#entity-1\"},\n        },\n    )\n\n    # Apply migration - should not overwrite existing values\n    await apply_migrations(repo, \"1.0.0\", \"2.0.0\")\n\n    # Verify original created_at preserved (if_not_exists)\n    response = await client.get_item(\n        TableName=repo.table_name,\n        Key={\"PK\": {\"S\": \"ENTITY#entity-1\"}, \"SK\": {\"S\": \"#META\"}},\n    )\n    item = response[\"Item\"]\n    assert item[\"created_at\"][\"S\"] == original_time\n</code></pre>"},{"location":"migrations/#reference","title":"Reference","text":""},{"location":"migrations/#version-record-structure","title":"Version Record Structure","text":"<p>The version record is stored in DynamoDB:</p> Attribute Value Description PK <code>SYSTEM#</code> Partition key SK <code>#VERSION</code> Sort key schema_version <code>\"1.0.0\"</code> Current schema version lambda_version <code>\"1.2.0\"</code> Deployed Lambda version client_min_version <code>\"1.0.0\"</code> Minimum client version updated_at ISO timestamp Last update time updated_by <code>\"cli:1.2.0\"</code> What performed the update"},{"location":"migrations/#key-patterns-v100","title":"Key Patterns (v1.0.0)","text":"Pattern Example Description Entity metadata <code>PK=ENTITY#123, SK=#META</code> Entity configuration Bucket state <code>PK=ENTITY#123, SK=#BUCKET#gpt-4#rpm</code> Token bucket state Limit config <code>PK=ENTITY#123, SK=#LIMIT#gpt-4#rpm</code> Stored limit config Usage snapshot <code>PK=ENTITY#123, SK=#USAGE#gpt-4#2024-01-15</code> Usage data Version <code>PK=SYSTEM#, SK=#VERSION</code> Infrastructure version"},{"location":"migrations/#migration-api-reference","title":"Migration API Reference","text":"<pre><code>from zae_limiter.migrations import (\n    Migration,           # Migration dataclass\n    register_migration,  # Register a migration\n    get_migrations,      # Get all registered migrations\n    get_migrations_between,  # Get migrations between versions\n    apply_migrations,    # Apply migrations\n)\n\nfrom zae_limiter.version import (\n    CURRENT_SCHEMA_VERSION,  # Current schema version constant\n    parse_version,           # Parse version string\n    check_compatibility,     # Check client/infra compatibility\n    get_schema_version,      # Get current schema version\n    InfrastructureVersion,   # Version info dataclass\n    CompatibilityResult,     # Compatibility check result\n)\n</code></pre>"},{"location":"migrations/#cli-commands","title":"CLI Commands","text":"<pre><code># Check compatibility\nzae-limiter check --table-name TABLE --region REGION\n\n# Show version information\nzae-limiter version --table-name TABLE --region REGION\n\n# Upgrade infrastructure\nzae-limiter upgrade --table-name TABLE --region REGION [--lambda-only] [--force]\n</code></pre>"},{"location":"api/","title":"API Reference","text":"<p>This section contains the complete API documentation for zae-limiter, auto-generated from source code docstrings.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>The main components of the API are:</p> Component Description <code>RateLimiter</code> Async rate limiter client <code>SyncRateLimiter</code> Synchronous rate limiter client <code>Limit</code> Rate limit configuration <code>RateLimitExceeded</code> Exception when limit is exceeded"},{"location":"api/#quick-reference","title":"Quick Reference","text":""},{"location":"api/#creating-a-limiter","title":"Creating a Limiter","text":"<pre><code>from zae_limiter import RateLimiter, SyncRateLimiter\n\n# Async\nlimiter = RateLimiter(\n    table_name=\"rate_limits\",\n    region=\"us-east-1\",\n)\n\n# Sync\nlimiter = SyncRateLimiter(\n    table_name=\"rate_limits\",\n    region=\"us-east-1\",\n)\n</code></pre>"},{"location":"api/#defining-limits","title":"Defining Limits","text":"<pre><code>from zae_limiter import Limit\n\n# Factory methods\nLimit.per_second(\"rps\", 10)\nLimit.per_minute(\"rpm\", 100)\nLimit.per_hour(\"rph\", 1000)\nLimit.per_day(\"rpd\", 10000)\n\n# With burst capacity\nLimit.per_minute(\"tpm\", 10_000, burst=15_000)\n\n# Custom period\nLimit.custom(\"requests\", capacity=50, refill_period_seconds=30)\n</code></pre>"},{"location":"api/#acquiring-limits","title":"Acquiring Limits","text":"<pre><code>from zae_limiter import RateLimiter, Limit, RateLimitExceeded\n\nlimiter = RateLimiter(table_name=\"rate_limits\")\n\ntry:\n    async with limiter.acquire(\n        entity_id=\"user-123\",\n        resource=\"api\",\n        limits=[Limit.per_minute(\"rpm\", 100)],\n        consume={\"rpm\": 1},\n    ) as lease:\n        # Do work\n        await lease.adjust(rpm=5)  # Adjust if needed\nexcept RateLimitExceeded as e:\n    print(f\"Retry after: {e.retry_after_seconds}s\")\n</code></pre>"},{"location":"api/#handling-exceptions","title":"Handling Exceptions","text":"<pre><code>from zae_limiter import RateLimitExceeded, RateLimiterUnavailable\n\ntry:\n    async with limiter.acquire(...):\n        pass\nexcept RateLimitExceeded as e:\n    # Rate limit exceeded\n    print(e.retry_after_seconds)\n    print(e.violations)\n    print(e.as_dict())\nexcept RateLimiterUnavailable as e:\n    # DynamoDB unavailable\n    print(f\"Service unavailable: {e}\")\n</code></pre>"},{"location":"api/#module-structure","title":"Module Structure","text":"<pre><code>zae_limiter/\n\u251c\u2500\u2500 __init__.py        # Public API exports\n\u251c\u2500\u2500 limiter.py         # RateLimiter, SyncRateLimiter\n\u251c\u2500\u2500 models.py          # Limit, Entity, LimitStatus, BucketState\n\u251c\u2500\u2500 exceptions.py      # RateLimitExceeded, RateLimiterUnavailable\n\u251c\u2500\u2500 lease.py           # Lease context manager\n\u251c\u2500\u2500 bucket.py          # Token bucket algorithm\n\u251c\u2500\u2500 schema.py          # DynamoDB key builders\n\u251c\u2500\u2500 repository.py      # DynamoDB operations\n\u2514\u2500\u2500 cli.py             # CLI commands\n</code></pre>"},{"location":"api/#public-exports","title":"Public Exports","text":"<p>The following are exported from <code>zae_limiter</code>:</p> <pre><code>from zae_limiter import (\n    # Main classes\n    RateLimiter,\n    SyncRateLimiter,\n    Lease,\n    SyncLease,\n\n    # Models\n    Limit,\n    Entity,\n    LimitStatus,\n    BucketState,\n\n    # Enums\n    FailureMode,\n\n    # Exceptions - Base\n    ZAELimiterError,\n\n    # Exceptions - Rate Limit\n    RateLimitExceeded,\n    RateLimiterUnavailable,\n\n    # Exceptions - Entity\n    EntityNotFoundError,\n    EntityExistsError,\n\n    # Exceptions - Infrastructure\n    StackCreationError,\n    StackAlreadyExistsError,\n    InfrastructureNotFoundError,\n\n    # Exceptions - Version\n    VersionMismatchError,\n    IncompatibleSchemaError,\n)\n</code></pre>"},{"location":"api/#detailed-documentation","title":"Detailed Documentation","text":"<ul> <li>RateLimiter - Main rate limiter classes</li> <li>Models - Data models and configuration</li> <li>Exceptions - Exception types and handling</li> </ul>"},{"location":"api/exceptions/","title":"Exceptions","text":"<p>Exception types raised by zae-limiter.</p>"},{"location":"api/exceptions/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>ZAELimiterError (base)\n\u251c\u2500\u2500 RateLimitError\n\u2502   \u251c\u2500\u2500 RateLimitExceeded\n\u2502   \u2514\u2500\u2500 RateLimiterUnavailable\n\u251c\u2500\u2500 EntityError\n\u2502   \u251c\u2500\u2500 EntityNotFoundError\n\u2502   \u2514\u2500\u2500 EntityExistsError\n\u251c\u2500\u2500 InfrastructureError\n\u2502   \u251c\u2500\u2500 StackCreationError\n\u2502   \u251c\u2500\u2500 StackAlreadyExistsError\n\u2502   \u2514\u2500\u2500 InfrastructureNotFoundError\n\u2514\u2500\u2500 VersionError\n    \u251c\u2500\u2500 VersionMismatchError\n    \u2514\u2500\u2500 IncompatibleSchemaError\n</code></pre>"},{"location":"api/exceptions/#base-exception","title":"Base Exception","text":""},{"location":"api/exceptions/#zae_limiter.exceptions.ZAELimiterError","title":"ZAELimiterError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all zae-limiter errors.</p> <p>All exceptions raised by this library inherit from this class, allowing callers to catch all library-specific errors with a single except clause.</p>"},{"location":"api/exceptions/#rate-limit-exceptions","title":"Rate Limit Exceptions","text":""},{"location":"api/exceptions/#zae_limiter.exceptions.RateLimitExceeded","title":"RateLimitExceeded","text":"<pre><code>RateLimitExceeded(statuses)\n</code></pre> <p>               Bases: <code>RateLimitError</code></p> <p>Raised when one or more rate limits would be exceeded.</p> <p>Provides full visibility into ALL limits that were checked, both passed and failed, to help callers understand the full picture.</p> <p>Attributes:</p> Name Type Description <code>statuses</code> <p>Status of ALL limits checked (both passed and failed)</p> <code>violations</code> <p>Only the limits that were exceeded</p> <code>passed</code> <p>Only the limits that passed</p> <code>retry_after_seconds</code> <p>Time until ALL requested capacity is available</p> <code>primary_violation</code> <p>The violation with longest retry time (bottleneck)</p>"},{"location":"api/exceptions/#zae_limiter.exceptions.RateLimitExceeded.retry_after_header","title":"retry_after_header  <code>property</code>","text":"<pre><code>retry_after_header\n</code></pre> <p>Value for HTTP Retry-After header (integer seconds).</p>"},{"location":"api/exceptions/#zae_limiter.exceptions.RateLimitExceeded.as_dict","title":"as_dict","text":"<pre><code>as_dict()\n</code></pre> <p>Serialize for JSON API responses.</p> <p>Returns a dictionary suitable for returning in a 429 response body.</p>"},{"location":"api/exceptions/#zae_limiter.exceptions.RateLimiterUnavailable","title":"RateLimiterUnavailable","text":"<pre><code>RateLimiterUnavailable(message, cause=None, *, table_name=None, entity_id=None, resource=None)\n</code></pre> <p>               Bases: <code>RateLimitError</code></p> <p>Raised when DynamoDB is unavailable and failure_mode=FAIL_CLOSED.</p> <p>This indicates a transient infrastructure issue, not a rate limit.</p> <p>Attributes:</p> Name Type Description <code>cause</code> <p>The underlying exception that caused the unavailability</p> <code>table_name</code> <p>The DynamoDB table that was being accessed</p> <code>entity_id</code> <p>The entity being rate limited (if applicable)</p> <code>resource</code> <p>The resource being rate limited (if applicable)</p>"},{"location":"api/exceptions/#entity-exceptions","title":"Entity Exceptions","text":""},{"location":"api/exceptions/#zae_limiter.exceptions.EntityNotFoundError","title":"EntityNotFoundError","text":"<pre><code>EntityNotFoundError(entity_id)\n</code></pre> <p>               Bases: <code>EntityError</code></p> <p>Raised when an entity is not found.</p>"},{"location":"api/exceptions/#zae_limiter.exceptions.EntityExistsError","title":"EntityExistsError","text":"<pre><code>EntityExistsError(entity_id)\n</code></pre> <p>               Bases: <code>EntityError</code></p> <p>Raised when trying to create an entity that already exists.</p>"},{"location":"api/exceptions/#infrastructure-exceptions","title":"Infrastructure Exceptions","text":""},{"location":"api/exceptions/#zae_limiter.exceptions.StackCreationError","title":"StackCreationError","text":"<pre><code>StackCreationError(stack_name, reason, events=None)\n</code></pre> <p>               Bases: <code>InfrastructureError</code></p> <p>Raised when CloudFormation stack creation fails.</p>"},{"location":"api/exceptions/#zae_limiter.exceptions.StackAlreadyExistsError","title":"StackAlreadyExistsError","text":"<pre><code>StackAlreadyExistsError(stack_name, reason, events=None)\n</code></pre> <p>               Bases: <code>StackCreationError</code></p> <p>Raised when stack already exists (informational).</p>"},{"location":"api/exceptions/#zae_limiter.exceptions.InfrastructureNotFoundError","title":"InfrastructureNotFoundError","text":"<pre><code>InfrastructureNotFoundError(table_name, stack_name=None)\n</code></pre> <p>               Bases: <code>InfrastructureError</code></p> <p>Raised when expected infrastructure doesn't exist.</p> <p>This typically means the CloudFormation stack or DynamoDB table hasn't been deployed yet.</p>"},{"location":"api/exceptions/#version-exceptions","title":"Version Exceptions","text":""},{"location":"api/exceptions/#zae_limiter.exceptions.VersionMismatchError","title":"VersionMismatchError","text":"<pre><code>VersionMismatchError(client_version, schema_version, lambda_version, message, can_auto_update=False)\n</code></pre> <p>               Bases: <code>VersionError</code></p> <p>Raised when client and infrastructure versions are incompatible.</p> <p>This error indicates that the client library version doesn't match the deployed infrastructure and auto-update is disabled or failed.</p>"},{"location":"api/exceptions/#zae_limiter.exceptions.IncompatibleSchemaError","title":"IncompatibleSchemaError","text":"<pre><code>IncompatibleSchemaError(client_version, schema_version, message, migration_guide_url=None)\n</code></pre> <p>               Bases: <code>VersionError</code></p> <p>Raised when schema version requires manual migration.</p> <p>This indicates a major version difference that cannot be automatically reconciled.</p>"},{"location":"api/exceptions/#exception-handling-examples","title":"Exception Handling Examples","text":""},{"location":"api/exceptions/#basic-handling","title":"Basic Handling","text":"<pre><code>from zae_limiter import RateLimitExceeded, RateLimiterUnavailable\n\ntry:\n    async with limiter.acquire(\n        entity_id=\"user-123\",\n        resource=\"api\",\n        limits=[Limit.per_minute(\"rpm\", 100)],\n        consume={\"rpm\": 1},\n    ):\n        await do_work()\nexcept RateLimitExceeded as e:\n    # Handle rate limit exceeded\n    print(f\"Rate limited. Retry after {e.retry_after_seconds}s\")\nexcept RateLimiterUnavailable as e:\n    # Handle service unavailable\n    print(f\"Service unavailable: {e}\")\n</code></pre>"},{"location":"api/exceptions/#http-api-response","title":"HTTP API Response","text":"<pre><code>from fastapi import HTTPException\nfrom fastapi.responses import JSONResponse\n\n@app.post(\"/api/endpoint\")\nasync def endpoint():\n    try:\n        async with limiter.acquire(...):\n            return await process_request()\n    except RateLimitExceeded as e:\n        return JSONResponse(\n            status_code=429,\n            content=e.as_dict(),\n            headers={\"Retry-After\": e.retry_after_header},\n        )\n    except RateLimiterUnavailable:\n        raise HTTPException(status_code=503, detail=\"Service temporarily unavailable\")\n</code></pre>"},{"location":"api/exceptions/#detailed-error-information","title":"Detailed Error Information","text":"<pre><code>try:\n    async with limiter.acquire(...):\n        pass\nexcept RateLimitExceeded as e:\n    # All limit statuses (both passed and failed)\n    for status in e.statuses:\n        print(f\"Limit: {status.limit_name}\")\n        print(f\"  Entity: {status.entity_id}\")\n        print(f\"  Available: {status.available}\")\n        print(f\"  Requested: {status.requested}\")\n        print(f\"  Exceeded: {status.exceeded}\")\n        print(f\"  Retry after: {status.retry_after_seconds}s\")\n\n    # Only the violations\n    print(f\"Violations: {len(e.violations)}\")\n    for v in e.violations:\n        print(f\"  - {v.limit_name}: {v.available} available\")\n\n    # Only the passed limits\n    print(f\"Passed: {len(e.passed)}\")\n\n    # Primary bottleneck (longest wait time)\n    print(f\"Bottleneck: {e.primary_violation.limit_name}\")\n    print(f\"Total retry after: {e.retry_after_seconds}s\")\n</code></pre>"},{"location":"api/exceptions/#as_dict-output","title":"as_dict() Output","text":"<p>The <code>as_dict()</code> method returns a dictionary suitable for API responses:</p> <pre><code>{\n    \"error\": \"rate_limit_exceeded\",\n    \"message\": \"Rate limit exceeded for user-123/api: [rpm]. Retry after 45.2s\",\n    \"retry_after_seconds\": 45.2,\n    \"retry_after_ms\": 45200,\n    \"limits\": [\n        {\n            \"entity_id\": \"user-123\",\n            \"resource\": \"api\",\n            \"limit_name\": \"rpm\",\n            \"capacity\": 100,\n            \"burst\": 100,\n            \"available\": -5,\n            \"requested\": 10,\n            \"exceeded\": True,\n            \"retry_after_seconds\": 45.2,\n        },\n        {\n            \"entity_id\": \"user-123\",\n            \"resource\": \"api\",\n            \"limit_name\": \"tpm\",\n            \"capacity\": 10000,\n            \"burst\": 10000,\n            \"available\": 8500,\n            \"requested\": 500,\n            \"exceeded\": False,\n            \"retry_after_seconds\": 0.0,\n        },\n    ],\n}\n</code></pre> <p>Single <code>limits</code> array</p> <p>All limits (both exceeded and passed) are returned in a single <code>limits</code> array. Use the <code>exceeded</code> field to distinguish between violations and passed limits.</p>"},{"location":"api/limiter/","title":"RateLimiter","text":"<p>The main rate limiter classes for async and sync usage.</p>"},{"location":"api/limiter/#ratelimiter-async","title":"RateLimiter (Async)","text":""},{"location":"api/limiter/#zae_limiter.limiter.RateLimiter","title":"RateLimiter","text":"<pre><code>RateLimiter(table_name, region=None, endpoint_url=None, stack_options=None, failure_mode=FAIL_CLOSED, auto_update=True, strict_version=True, skip_version_check=False)\n</code></pre> <p>Async rate limiter backed by DynamoDB.</p> <p>Implements token bucket algorithm with support for: - Multiple limits per entity/resource - Two-level hierarchy (parent/child entities) - Cascade mode (consume from entity + parent) - Stored limit configs - Usage analytics</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>DynamoDB table name</p> required <code>region</code> <code>str | None</code> <p>AWS region</p> <code>None</code> <code>endpoint_url</code> <code>str | None</code> <p>DynamoDB endpoint URL (for local development)</p> <code>None</code> <code>stack_options</code> <code>StackOptions | None</code> <p>Stack configuration for auto-creation (None = don't create)</p> <code>None</code> <code>failure_mode</code> <code>FailureMode</code> <p>Behavior when DynamoDB is unavailable</p> <code>FAIL_CLOSED</code> <code>auto_update</code> <code>bool</code> <p>Auto-update Lambda when version mismatch detected</p> <code>True</code> <code>strict_version</code> <code>bool</code> <p>Fail if version mismatch (when auto_update is False)</p> <code>True</code> <code>skip_version_check</code> <code>bool</code> <p>Skip all version checks (dangerous)</p> <code>False</code>"},{"location":"api/limiter/#zae_limiter.limiter.RateLimiter.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the underlying connections.</p>"},{"location":"api/limiter/#zae_limiter.limiter.RateLimiter.create_entity","title":"create_entity  <code>async</code>","text":"<pre><code>create_entity(entity_id, name=None, parent_id=None, metadata=None)\n</code></pre> <p>Create a new entity.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Unique identifier for the entity</p> required <code>name</code> <code>str | None</code> <p>Human-readable name (defaults to entity_id)</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>Parent entity ID (None for root/project entities)</p> <code>None</code> <code>metadata</code> <code>dict[str, str] | None</code> <p>Additional metadata to store</p> <code>None</code> <p>Returns:</p> Type Description <code>Entity</code> <p>The created Entity</p> <p>Raises:</p> Type Description <code>EntityExistsError</code> <p>If entity already exists</p>"},{"location":"api/limiter/#zae_limiter.limiter.RateLimiter.get_entity","title":"get_entity  <code>async</code>","text":"<pre><code>get_entity(entity_id)\n</code></pre> <p>Get an entity by ID.</p>"},{"location":"api/limiter/#zae_limiter.limiter.RateLimiter.delete_entity","title":"delete_entity  <code>async</code>","text":"<pre><code>delete_entity(entity_id)\n</code></pre> <p>Delete an entity and all its related data.</p>"},{"location":"api/limiter/#zae_limiter.limiter.RateLimiter.get_children","title":"get_children  <code>async</code>","text":"<pre><code>get_children(parent_id)\n</code></pre> <p>Get all children of a parent entity.</p>"},{"location":"api/limiter/#zae_limiter.limiter.RateLimiter.acquire","title":"acquire  <code>async</code>","text":"<pre><code>acquire(entity_id, resource, limits, consume, cascade=False, use_stored_limits=False, failure_mode=None)\n</code></pre> <p>Acquire rate limit capacity.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity to acquire capacity for</p> required <code>resource</code> <code>str</code> <p>Resource being accessed (e.g., \"gpt-4\")</p> required <code>limits</code> <code>list[Limit]</code> <p>Default limits to apply</p> required <code>consume</code> <code>dict[str, int]</code> <p>Amounts to consume by limit name</p> required <code>cascade</code> <code>bool</code> <p>If True, also consume from parent entity</p> <code>False</code> <code>use_stored_limits</code> <code>bool</code> <p>If True, use stored limits if available</p> <code>False</code> <code>failure_mode</code> <code>FailureMode | None</code> <p>Override default failure mode</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncIterator[Lease]</code> <p>Lease for managing additional consumption</p> <p>Raises:</p> Type Description <code>RateLimitExceeded</code> <p>If any limit would be exceeded</p> <code>RateLimiterUnavailable</code> <p>If DynamoDB unavailable and FAIL_CLOSED</p>"},{"location":"api/limiter/#zae_limiter.limiter.RateLimiter.available","title":"available  <code>async</code>","text":"<pre><code>available(entity_id, resource, limits, use_stored_limits=False)\n</code></pre> <p>Check available capacity without consuming.</p> <p>Returns minimum available across entity (and parent if cascade). Can return negative values if bucket is in debt.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity to check</p> required <code>resource</code> <code>str</code> <p>Resource to check</p> required <code>limits</code> <code>list[Limit]</code> <p>Default limits</p> required <code>use_stored_limits</code> <code>bool</code> <p>Use stored limits if available</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>Dict mapping limit_name -&gt; available tokens</p>"},{"location":"api/limiter/#zae_limiter.limiter.RateLimiter.time_until_available","title":"time_until_available  <code>async</code>","text":"<pre><code>time_until_available(entity_id, resource, limits, needed, use_stored_limits=False)\n</code></pre> <p>Calculate seconds until requested capacity is available.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity to check</p> required <code>resource</code> <code>str</code> <p>Resource to check</p> required <code>limits</code> <code>list[Limit]</code> <p>Default limits</p> required <code>needed</code> <code>dict[str, int]</code> <p>Required amounts by limit name</p> required <code>use_stored_limits</code> <code>bool</code> <p>Use stored limits if available</p> <code>False</code> <p>Returns:</p> Type Description <code>float</code> <p>Seconds until available (0.0 if already available)</p>"},{"location":"api/limiter/#zae_limiter.limiter.RateLimiter.set_limits","title":"set_limits  <code>async</code>","text":"<pre><code>set_limits(entity_id, limits, resource=DEFAULT_RESOURCE)\n</code></pre> <p>Store limit configs for an entity.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity to set limits for</p> required <code>limits</code> <code>list[Limit]</code> <p>Limits to store</p> required <code>resource</code> <code>str</code> <p>Resource these limits apply to (or default)</p> <code>DEFAULT_RESOURCE</code>"},{"location":"api/limiter/#zae_limiter.limiter.RateLimiter.get_limits","title":"get_limits  <code>async</code>","text":"<pre><code>get_limits(entity_id, resource=DEFAULT_RESOURCE)\n</code></pre> <p>Get stored limit configs for an entity.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity to get limits for</p> required <code>resource</code> <code>str</code> <p>Resource to get limits for</p> <code>DEFAULT_RESOURCE</code> <p>Returns:</p> Type Description <code>list[Limit]</code> <p>List of stored limits (empty if none)</p>"},{"location":"api/limiter/#zae_limiter.limiter.RateLimiter.delete_limits","title":"delete_limits  <code>async</code>","text":"<pre><code>delete_limits(entity_id, resource=DEFAULT_RESOURCE)\n</code></pre> <p>Delete stored limit configs for an entity.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity to delete limits for</p> required <code>resource</code> <code>str</code> <p>Resource to delete limits for</p> <code>DEFAULT_RESOURCE</code>"},{"location":"api/limiter/#zae_limiter.limiter.RateLimiter.get_resource_capacity","title":"get_resource_capacity  <code>async</code>","text":"<pre><code>get_resource_capacity(resource, limit_name, parents_only=False)\n</code></pre> <p>Get aggregated capacity for a resource across all entities.</p> <p>Parameters:</p> Name Type Description Default <code>resource</code> <code>str</code> <p>Resource to query</p> required <code>limit_name</code> <code>str</code> <p>Limit name to query</p> required <code>parents_only</code> <code>bool</code> <p>If True, only include parent entities</p> <code>False</code> <p>Returns:</p> Type Description <code>ResourceCapacity</code> <p>ResourceCapacity with aggregated data</p>"},{"location":"api/limiter/#zae_limiter.limiter.RateLimiter.create_stack","title":"create_stack  <code>async</code>","text":"<pre><code>create_stack(stack_name=None, stack_options=None)\n</code></pre> <p>Create CloudFormation stack for infrastructure.</p> <p>Parameters:</p> Name Type Description Default <code>stack_name</code> <code>str | None</code> <p>Override stack name (default: auto-generated)</p> <code>None</code> <code>stack_options</code> <code>StackOptions | None</code> <p>Stack configuration</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dict with stack_id, stack_name, and status</p> <p>Raises:</p> Type Description <code>StackCreationError</code> <p>If stack creation fails</p>"},{"location":"api/limiter/#zae_limiter.limiter.RateLimiter.delete_stack","title":"delete_stack  <code>async</code>","text":"<pre><code>delete_stack(stack_name=None)\n</code></pre> <p>Delete the CloudFormation stack and all associated resources.</p> <p>This method permanently removes the CloudFormation stack, including:</p> <ul> <li>DynamoDB table and all stored data</li> <li>Lambda aggregator function (if deployed)</li> <li>IAM roles and CloudWatch log groups</li> <li>All other stack resources</li> </ul> <p>The method waits for deletion to complete before returning. If the stack doesn't exist, no error is raised.</p> <p>Parameters:</p> Name Type Description Default <code>stack_name</code> <code>str | None</code> <p>CloudFormation stack name to delete. Default: auto-generated from table name (<code>zae-limiter-{table_name}</code>)</p> <code>None</code> <p>Raises:</p> Type Description <code>StackCreationError</code> <p>If deletion fails (e.g., permission denied, resources in use, or CloudFormation service error)</p> Example <p>Cleanup after integration testing::</p> <pre><code>limiter = RateLimiter(\n    table_name=\"test_limits\",\n    region=\"us-east-1\",\n    stack_options=StackOptions(),\n)\n\nasync with limiter:\n    # Run tests...\n    pass\n\n# Clean up infrastructure\nawait limiter.delete_stack()\n</code></pre> Warning <p>This operation is irreversible. All rate limit state, entity data, and usage history will be permanently deleted.</p>"},{"location":"api/limiter/#syncratelimiter","title":"SyncRateLimiter","text":""},{"location":"api/limiter/#zae_limiter.limiter.SyncRateLimiter","title":"SyncRateLimiter","text":"<pre><code>SyncRateLimiter(table_name, region=None, endpoint_url=None, stack_options=None, failure_mode=FAIL_CLOSED, auto_update=True, strict_version=True, skip_version_check=False)\n</code></pre> <p>Synchronous rate limiter backed by DynamoDB.</p> <p>Wraps RateLimiter, running async operations in an event loop.</p>"},{"location":"api/limiter/#zae_limiter.limiter.SyncRateLimiter.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the underlying connections.</p>"},{"location":"api/limiter/#zae_limiter.limiter.SyncRateLimiter.create_entity","title":"create_entity","text":"<pre><code>create_entity(entity_id, name=None, parent_id=None, metadata=None)\n</code></pre> <p>Create a new entity.</p>"},{"location":"api/limiter/#zae_limiter.limiter.SyncRateLimiter.get_entity","title":"get_entity","text":"<pre><code>get_entity(entity_id)\n</code></pre> <p>Get an entity by ID.</p>"},{"location":"api/limiter/#zae_limiter.limiter.SyncRateLimiter.delete_entity","title":"delete_entity","text":"<pre><code>delete_entity(entity_id)\n</code></pre> <p>Delete an entity and all its related data.</p>"},{"location":"api/limiter/#zae_limiter.limiter.SyncRateLimiter.get_children","title":"get_children","text":"<pre><code>get_children(parent_id)\n</code></pre> <p>Get all children of a parent entity.</p>"},{"location":"api/limiter/#zae_limiter.limiter.SyncRateLimiter.acquire","title":"acquire","text":"<pre><code>acquire(entity_id, resource, limits, consume, cascade=False, use_stored_limits=False, failure_mode=None)\n</code></pre> <p>Acquire rate limit capacity (synchronous).</p>"},{"location":"api/limiter/#zae_limiter.limiter.SyncRateLimiter.available","title":"available","text":"<pre><code>available(entity_id, resource, limits, use_stored_limits=False)\n</code></pre> <p>Check available capacity without consuming.</p>"},{"location":"api/limiter/#zae_limiter.limiter.SyncRateLimiter.time_until_available","title":"time_until_available","text":"<pre><code>time_until_available(entity_id, resource, limits, needed, use_stored_limits=False)\n</code></pre> <p>Calculate seconds until requested capacity is available.</p>"},{"location":"api/limiter/#zae_limiter.limiter.SyncRateLimiter.set_limits","title":"set_limits","text":"<pre><code>set_limits(entity_id, limits, resource=DEFAULT_RESOURCE)\n</code></pre> <p>Store limit configs for an entity.</p>"},{"location":"api/limiter/#zae_limiter.limiter.SyncRateLimiter.get_limits","title":"get_limits","text":"<pre><code>get_limits(entity_id, resource=DEFAULT_RESOURCE)\n</code></pre> <p>Get stored limit configs for an entity.</p>"},{"location":"api/limiter/#zae_limiter.limiter.SyncRateLimiter.delete_limits","title":"delete_limits","text":"<pre><code>delete_limits(entity_id, resource=DEFAULT_RESOURCE)\n</code></pre> <p>Delete stored limit configs for an entity.</p>"},{"location":"api/limiter/#zae_limiter.limiter.SyncRateLimiter.get_resource_capacity","title":"get_resource_capacity","text":"<pre><code>get_resource_capacity(resource, limit_name, parents_only=False)\n</code></pre> <p>Get aggregated capacity for a resource across all entities.</p>"},{"location":"api/limiter/#zae_limiter.limiter.SyncRateLimiter.create_stack","title":"create_stack","text":"<pre><code>create_stack(stack_name=None, stack_options=None)\n</code></pre> <p>Create CloudFormation stack for infrastructure.</p>"},{"location":"api/limiter/#zae_limiter.limiter.SyncRateLimiter.delete_stack","title":"delete_stack","text":"<pre><code>delete_stack(stack_name=None)\n</code></pre> <p>Delete the CloudFormation stack and all associated resources.</p> <p>Synchronous wrapper for :meth:<code>RateLimiter.delete_stack</code>. See the async version for full documentation.</p> <p>Parameters:</p> Name Type Description Default <code>stack_name</code> <code>str | None</code> <p>CloudFormation stack name to delete. Default: auto-generated from table name (<code>zae-limiter-{table_name}</code>)</p> <code>None</code> <p>Raises:</p> Type Description <code>StackCreationError</code> <p>If deletion fails</p> Example <p>Cleanup after testing::</p> <pre><code>limiter = SyncRateLimiter(\n    table_name=\"test_limits\",\n    region=\"us-east-1\",\n    stack_options=StackOptions(),\n)\n\nwith limiter:\n    # Run tests...\n    pass\n\n# Clean up infrastructure\nlimiter.delete_stack()\n</code></pre> Warning <p>This operation is irreversible. All data will be permanently deleted.</p>"},{"location":"api/limiter/#failuremode","title":"FailureMode","text":""},{"location":"api/limiter/#zae_limiter.limiter.FailureMode","title":"FailureMode","text":"<p>               Bases: <code>Enum</code></p> <p>Behavior when DynamoDB is unavailable.</p>"},{"location":"api/models/","title":"Models","text":"<p>Data models for rate limit configuration and status.</p>"},{"location":"api/models/#limit","title":"Limit","text":""},{"location":"api/models/#zae_limiter.models.Limit","title":"Limit  <code>dataclass</code>","text":"<pre><code>Limit(name, capacity, burst, refill_amount, refill_period_seconds)\n</code></pre> <p>Token bucket rate limit configuration.</p> <p>Refill rate is stored as a fraction (refill_amount / refill_period_seconds) to avoid floating point precision issues.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique identifier for this limit type (e.g., \"rpm\", \"tpm\")</p> <code>capacity</code> <code>int</code> <p>Max tokens that refill over the period (sustained rate)</p> <code>burst</code> <code>int</code> <p>Max tokens in bucket (&gt;= capacity, allows bursting)</p> <code>refill_amount</code> <code>int</code> <p>Numerator of refill rate</p> <code>refill_period_seconds</code> <code>int</code> <p>Denominator of refill rate</p>"},{"location":"api/models/#zae_limiter.models.Limit.refill_rate","title":"refill_rate  <code>property</code>","text":"<pre><code>refill_rate\n</code></pre> <p>Tokens per second (for display/debugging).</p>"},{"location":"api/models/#zae_limiter.models.Limit.per_second","title":"per_second  <code>classmethod</code>","text":"<pre><code>per_second(name, capacity, burst=None)\n</code></pre> <p>Create a limit that refills <code>capacity</code> tokens per second.</p>"},{"location":"api/models/#zae_limiter.models.Limit.per_minute","title":"per_minute  <code>classmethod</code>","text":"<pre><code>per_minute(name, capacity, burst=None)\n</code></pre> <p>Create a limit that refills <code>capacity</code> tokens per minute.</p>"},{"location":"api/models/#zae_limiter.models.Limit.per_hour","title":"per_hour  <code>classmethod</code>","text":"<pre><code>per_hour(name, capacity, burst=None)\n</code></pre> <p>Create a limit that refills <code>capacity</code> tokens per hour.</p>"},{"location":"api/models/#zae_limiter.models.Limit.per_day","title":"per_day  <code>classmethod</code>","text":"<pre><code>per_day(name, capacity, burst=None)\n</code></pre> <p>Create a limit that refills <code>capacity</code> tokens per day.</p>"},{"location":"api/models/#zae_limiter.models.Limit.custom","title":"custom  <code>classmethod</code>","text":"<pre><code>custom(name, capacity, refill_amount, refill_period_seconds, burst=None)\n</code></pre> <p>Create a custom limit with explicit refill rate.</p> Sustain 100/sec with burst of 1000 <p>Limit.custom(\"requests\", capacity=100, refill_amount=100,             refill_period_seconds=1, burst=1000)</p>"},{"location":"api/models/#zae_limiter.models.Limit.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize to dictionary for storage.</p>"},{"location":"api/models/#zae_limiter.models.Limit.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Deserialize from dictionary.</p>"},{"location":"api/models/#entity","title":"Entity","text":""},{"location":"api/models/#zae_limiter.models.Entity","title":"Entity  <code>dataclass</code>","text":"<pre><code>Entity(id, name=None, parent_id=None, metadata=dict(), created_at=None)\n</code></pre> <p>An entity that can have rate limits applied.</p> <p>Entities can be parents (projects) or children (API keys). Children have a parent_id reference.</p> <p>Note: This model does not validate in post_init to support DynamoDB deserialization and avoid performance overhead. Validation is performed in Repository.create_entity() at the API boundary.</p>"},{"location":"api/models/#zae_limiter.models.Entity.is_parent","title":"is_parent  <code>property</code>","text":"<pre><code>is_parent\n</code></pre> <p>True if this entity has no parent (is a root/project).</p>"},{"location":"api/models/#zae_limiter.models.Entity.is_child","title":"is_child  <code>property</code>","text":"<pre><code>is_child\n</code></pre> <p>True if this entity has a parent.</p>"},{"location":"api/models/#limitstatus","title":"LimitStatus","text":""},{"location":"api/models/#zae_limiter.models.LimitStatus","title":"LimitStatus  <code>dataclass</code>","text":"<pre><code>LimitStatus(entity_id, resource, limit_name, limit, available, requested, exceeded, retry_after_seconds)\n</code></pre> <p>Status of a specific limit check.</p> <p>Returned in RateLimitExceeded to provide full visibility into all limits that were checked.</p> <p>Note: This is an internal model created by the limiter from validated inputs. No validation is performed here to avoid performance overhead.</p>"},{"location":"api/models/#zae_limiter.models.LimitStatus.deficit","title":"deficit  <code>property</code>","text":"<pre><code>deficit\n</code></pre> <p>How many tokens short we are (0 if not exceeded).</p>"},{"location":"api/models/#bucketstate","title":"BucketState","text":""},{"location":"api/models/#zae_limiter.models.BucketState","title":"BucketState  <code>dataclass</code>","text":"<pre><code>BucketState(entity_id, resource, limit_name, tokens_milli, last_refill_ms, capacity_milli, burst_milli, refill_amount_milli, refill_period_ms)\n</code></pre> <p>Internal state of a token bucket.</p> <p>All token values are stored in millitokens (x1000) for precision.</p> <p>Note: This is an internal model. Validation is performed in from_limit() for user-provided inputs, not in post_init to support DynamoDB deserialization and avoid performance overhead on frequent operations.</p>"},{"location":"api/models/#zae_limiter.models.BucketState.tokens","title":"tokens  <code>property</code>","text":"<pre><code>tokens\n</code></pre> <p>Current tokens (not millitokens).</p>"},{"location":"api/models/#zae_limiter.models.BucketState.capacity","title":"capacity  <code>property</code>","text":"<pre><code>capacity\n</code></pre> <p>Capacity (not millitokens).</p>"},{"location":"api/models/#zae_limiter.models.BucketState.burst","title":"burst  <code>property</code>","text":"<pre><code>burst\n</code></pre> <p>Burst (not millitokens).</p>"},{"location":"api/models/#zae_limiter.models.BucketState.from_limit","title":"from_limit  <code>classmethod</code>","text":"<pre><code>from_limit(entity_id, resource, limit, now_ms)\n</code></pre> <p>Create a new bucket at full capacity from a Limit.</p> <p>Note: This is an internal factory method. Validation of entity_id and resource is performed at the API boundary (RateLimiter public methods) before calling this method.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>str</code> <p>Entity identifier (pre-validated by caller)</p> required <code>resource</code> <code>str</code> <p>Resource name (pre-validated by caller)</p> required <code>limit</code> <code>Limit</code> <p>Limit configuration (validated via post_init)</p> required <code>now_ms</code> <code>int</code> <p>Current time in milliseconds</p> required"},{"location":"guide/basic-usage/","title":"Basic Usage","text":"<p>This guide covers common rate limiting patterns with zae-limiter.</p>"},{"location":"guide/basic-usage/#the-acquire-context-manager","title":"The Acquire Context Manager","text":"<p>The <code>acquire()</code> method is the primary API for rate limiting:</p> <pre><code>async with limiter.acquire(\n    entity_id=\"user-123\",      # Who is being rate limited\n    resource=\"gpt-4\",          # What resource they're accessing\n    limits=[...],              # Rate limit definitions\n    consume={\"rpm\": 1},        # How much to consume\n) as lease:\n    # Your code here\n    pass\n</code></pre> <p>Behavior:</p> <ul> <li>On entry: Checks limits and consumes tokens</li> <li>On success: Commits the consumption</li> <li>On exception: Rolls back the consumption</li> </ul>"},{"location":"guide/basic-usage/#multiple-limits","title":"Multiple Limits","text":"<p>Track multiple limits in a single call:</p> <pre><code>async with limiter.acquire(\n    entity_id=\"api-key-123\",\n    resource=\"gpt-4\",\n    limits=[\n        Limit.per_minute(\"rpm\", 100),       # 100 requests/minute\n        Limit.per_minute(\"tpm\", 10_000),    # 10,000 tokens/minute\n        Limit.per_hour(\"rph\", 1_000),       # 1,000 requests/hour\n    ],\n    consume={\"rpm\": 1, \"tpm\": 500, \"rph\": 1},\n) as lease:\n    response = await call_llm()\n</code></pre> <p>All limits are checked atomically. If any limit is exceeded, the request is rejected.</p>"},{"location":"guide/basic-usage/#burst-capacity","title":"Burst Capacity","text":"<p>Allow temporary bursts above the sustained rate:</p> <pre><code># Sustain 10k tokens/minute, but allow bursts up to 15k\nlimits = [\n    Limit.per_minute(\"tpm\", 10_000, burst=15_000),\n]\n</code></pre> <p>The bucket starts full at <code>burst</code> capacity and refills at <code>capacity</code> tokens per period.</p>"},{"location":"guide/basic-usage/#adjusting-consumption","title":"Adjusting Consumption","text":"<p>Use <code>lease.adjust()</code> to modify consumption after the fact:</p> <pre><code>async with limiter.acquire(\n    entity_id=\"key-123\",\n    resource=\"gpt-4\",\n    limits=[Limit.per_minute(\"tpm\", 10_000)],\n    consume={\"tpm\": 500},  # Initial estimate\n) as lease:\n    response = await call_llm()\n\n    # Adjust based on actual usage\n    actual_tokens = response.usage.total_tokens\n    await lease.adjust(tpm=actual_tokens - 500)\n</code></pre> <p>Negative Adjustments</p> <p><code>adjust()</code> can go negative, allowing the bucket to go into debt. This is useful for post-hoc reconciliation when actual usage exceeds estimates.</p>"},{"location":"guide/basic-usage/#check-capacity-without-consuming","title":"Check Capacity Without Consuming","text":""},{"location":"guide/basic-usage/#check-available-tokens","title":"Check Available Tokens","text":"<pre><code>available = await limiter.available(\n    entity_id=\"key-123\",\n    resource=\"gpt-4\",\n    limits=[Limit.per_minute(\"tpm\", 10_000)],\n)\nprint(f\"Available tokens: {available['tpm']}\")\n</code></pre>"},{"location":"guide/basic-usage/#check-time-until-available","title":"Check Time Until Available","text":"<pre><code>wait_seconds = await limiter.time_until_available(\n    entity_id=\"key-123\",\n    resource=\"gpt-4\",\n    limits=[Limit.per_minute(\"tpm\", 10_000)],\n    needed={\"tpm\": 5_000},\n)\n\nif wait_seconds &gt; 0:\n    print(f\"Need to wait {wait_seconds}s for capacity\")\n</code></pre>"},{"location":"guide/basic-usage/#stored-limits","title":"Stored Limits","text":"<p>Configure per-entity limits stored in DynamoDB:</p> <pre><code># Set custom limits for a premium user\nawait limiter.set_limits(\n    entity_id=\"user-premium\",\n    limits=[\n        Limit.per_minute(\"rpm\", 500),        # 5x normal\n        Limit.per_minute(\"tpm\", 50_000),     # 5x normal\n    ],\n)\n\n# Use stored limits (falls back to defaults if not found)\nasync with limiter.acquire(\n    entity_id=\"user-premium\",\n    resource=\"gpt-4\",\n    limits=[Limit.per_minute(\"rpm\", 100)],  # Default\n    consume={\"rpm\": 1},\n    use_stored_limits=True,  # Use stored if available\n) as lease:\n    ...\n</code></pre>"},{"location":"guide/basic-usage/#entity-management","title":"Entity Management","text":""},{"location":"guide/basic-usage/#create-entities","title":"Create Entities","text":"<pre><code># Create a standalone entity\nawait limiter.create_entity(\n    entity_id=\"user-123\",\n    name=\"John Doe\",\n)\n\n# Create a child entity (API key under a project)\nawait limiter.create_entity(\n    entity_id=\"key-abc\",\n    parent_id=\"project-1\",\n    name=\"Production API Key\",\n)\n</code></pre>"},{"location":"guide/basic-usage/#get-entity-information","title":"Get Entity Information","text":"<pre><code>entity = await limiter.get_entity(\"user-123\")\nprint(f\"Name: {entity.name}\")\nprint(f\"Parent: {entity.parent_id}\")\n</code></pre>"},{"location":"guide/basic-usage/#error-handling","title":"Error Handling","text":""},{"location":"guide/basic-usage/#ratelimitexceeded-details","title":"RateLimitExceeded Details","text":"<pre><code>try:\n    async with limiter.acquire(...):\n        ...\nexcept RateLimitExceeded as e:\n    # All limit statuses\n    for status in e.statuses:\n        print(f\"{status.limit_name}: {status.available}/{status.limit.capacity}\")\n\n    # Only violations\n    for v in e.violations:\n        print(f\"Exceeded: {v.limit_name}\")\n\n    # Primary bottleneck\n    print(f\"Bottleneck: {e.primary_violation.limit_name}\")\n\n    # For API responses\n    return e.as_dict()\n</code></pre>"},{"location":"guide/basic-usage/#service-unavailable","title":"Service Unavailable","text":"<pre><code>from zae_limiter import RateLimiterUnavailable\n\ntry:\n    async with limiter.acquire(...):\n        ...\nexcept RateLimiterUnavailable as e:\n    # DynamoDB is unavailable\n    # Behavior depends on failure_mode setting\n    print(f\"Service unavailable: {e}\")\n</code></pre>"},{"location":"guide/basic-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Hierarchical Limits - Parent/child rate limiting</li> <li>LLM Integration - Token estimation patterns</li> <li>Failure Modes - Handling service outages</li> </ul>"},{"location":"guide/failure-modes/","title":"Failure Modes","text":"<p>zae-limiter provides configurable behavior when DynamoDB is unavailable. This guide covers the failure modes and how to choose the right one for your application.</p>"},{"location":"guide/failure-modes/#available-failure-modes","title":"Available Failure Modes","text":"Mode Behavior Use Case <code>FAIL_CLOSED</code> Reject requests Security-critical, billing <code>FAIL_OPEN</code> Allow requests User experience priority"},{"location":"guide/failure-modes/#fail_closed-default","title":"FAIL_CLOSED (Default)","text":"<p>When DynamoDB is unavailable, reject all rate-limited requests:</p> <pre><code>from zae_limiter import RateLimiter, FailureMode, RateLimiterUnavailable\n\nlimiter = RateLimiter(\n    table_name=\"rate_limits\",\n    failure_mode=FailureMode.FAIL_CLOSED,  # Default\n)\n\ntry:\n    async with limiter.acquire(...):\n        await do_work()\nexcept RateLimiterUnavailable as e:\n    # DynamoDB is unavailable\n    return JSONResponse(\n        status_code=503,\n        content={\"error\": \"Service temporarily unavailable\"},\n    )\n</code></pre> <p>When to use:</p> <ul> <li>Billing/metering systems where accuracy is critical</li> <li>Security-sensitive operations</li> <li>When over-consumption has significant costs</li> <li>Compliance requirements</li> </ul>"},{"location":"guide/failure-modes/#fail_open","title":"FAIL_OPEN","text":"<p>When DynamoDB is unavailable, allow requests to proceed:</p> <pre><code>limiter = RateLimiter(\n    table_name=\"rate_limits\",\n    failure_mode=FailureMode.FAIL_OPEN,\n)\n\n# Requests proceed even if DynamoDB is down\nasync with limiter.acquire(...):\n    await do_work()  # Runs without rate limiting\n</code></pre> <p>When to use:</p> <ul> <li>User experience is the priority</li> <li>Brief outages are acceptable</li> <li>Rate limiting is a soft limit</li> <li>Development/staging environments</li> </ul>"},{"location":"guide/failure-modes/#per-request-override","title":"Per-Request Override","text":"<p>Override the default failure mode for specific requests:</p> <pre><code># Default to FAIL_CLOSED\nlimiter = RateLimiter(\n    table_name=\"rate_limits\",\n    failure_mode=FailureMode.FAIL_CLOSED,\n)\n\n# But allow this specific request to proceed\nasync with limiter.acquire(\n    entity_id=\"user-123\",\n    resource=\"api\",\n    limits=[...],\n    consume={\"requests\": 1},\n    failure_mode=FailureMode.FAIL_OPEN,  # Override for this call\n) as lease:\n    await do_work()\n</code></pre>"},{"location":"guide/failure-modes/#handling-unavailable-errors","title":"Handling Unavailable Errors","text":"<p>The <code>RateLimiterUnavailable</code> exception includes details about the failure:</p> <pre><code>from zae_limiter import RateLimiterUnavailable\n\ntry:\n    async with limiter.acquire(...):\n        await do_work()\nexcept RateLimiterUnavailable as e:\n    # Log the underlying error\n    logger.error(f\"Rate limiter unavailable: {e}\")\n\n    # Decide how to handle\n    if is_critical_operation:\n        raise HTTPException(status_code=503)\n    else:\n        # Proceed without rate limiting\n        await do_work()\n</code></pre>"},{"location":"guide/failure-modes/#monitoring-and-alerting","title":"Monitoring and Alerting","text":"<p>Monitor for rate limiter unavailability:</p> <pre><code>import logging\nfrom zae_limiter import RateLimiterUnavailable\n\nlogger = logging.getLogger(__name__)\n\nasync def monitored_acquire(limiter, **kwargs):\n    try:\n        async with limiter.acquire(**kwargs) as lease:\n            yield lease\n    except RateLimiterUnavailable as e:\n        # Emit metric for monitoring\n        metrics.increment(\"rate_limiter.unavailable\")\n        logger.warning(f\"Rate limiter unavailable: {e}\")\n        raise\n</code></pre>"},{"location":"guide/failure-modes/#best-practices","title":"Best Practices","text":""},{"location":"guide/failure-modes/#1-choose-based-on-risk","title":"1. Choose Based on Risk","text":"<pre><code># High-risk: billing, security\nbilling_limiter = RateLimiter(\n    table_name=\"billing_limits\",\n    failure_mode=FailureMode.FAIL_CLOSED,\n)\n\n# Lower-risk: general API\napi_limiter = RateLimiter(\n    table_name=\"api_limits\",\n    failure_mode=FailureMode.FAIL_OPEN,\n)\n</code></pre>"},{"location":"guide/failure-modes/#2-use-circuit-breakers","title":"2. Use Circuit Breakers","text":"<p>Combine with circuit breakers to prevent cascading failures:</p> <pre><code>from circuitbreaker import circuit\n\n@circuit(failure_threshold=5, recovery_timeout=30)\nasync def rate_limited_operation(entity_id: str):\n    async with limiter.acquire(\n        entity_id=entity_id,\n        failure_mode=FailureMode.FAIL_CLOSED,\n        ...\n    ):\n        return await do_work()\n</code></pre>"},{"location":"guide/failure-modes/#3-graceful-degradation","title":"3. Graceful Degradation","text":"<p>Implement fallback behavior:</p> <pre><code>async def resilient_operation(entity_id: str):\n    try:\n        async with limiter.acquire(\n            entity_id=entity_id,\n            failure_mode=FailureMode.FAIL_CLOSED,\n            ...\n        ):\n            return await premium_operation()\n    except RateLimiterUnavailable:\n        # Fall back to degraded mode\n        logger.warning(\"Rate limiter unavailable, using fallback\")\n        return await basic_operation()\n</code></pre>"},{"location":"guide/failure-modes/#4-health-checks","title":"4. Health Checks","text":"<p>Include rate limiter health in your health checks:</p> <pre><code>async def health_check():\n    checks = {}\n\n    # Check rate limiter\n    try:\n        await limiter.available(\n            entity_id=\"health-check\",\n            resource=\"health\",\n            limits=[Limit.per_minute(\"requests\", 1)],\n        )\n        checks[\"rate_limiter\"] = \"healthy\"\n    except Exception as e:\n        checks[\"rate_limiter\"] = f\"unhealthy: {e}\"\n\n    return checks\n</code></pre>"},{"location":"guide/failure-modes/#dynamodb-resilience","title":"DynamoDB Resilience","text":"<p>DynamoDB itself is highly available, but consider:</p> <ul> <li>Region outages: Use multi-region tables for critical systems</li> <li>Throttling: Configure appropriate capacity</li> <li>Network issues: Set appropriate timeouts</li> </ul> <pre><code>limiter = RateLimiter(\n    table_name=\"rate_limits\",\n    region=\"us-east-1\",\n    # Configure boto3 client options\n    client_config={\n        \"connect_timeout\": 5,\n        \"read_timeout\": 10,\n        \"retries\": {\"max_attempts\": 3},\n    },\n)\n</code></pre>"},{"location":"guide/failure-modes/#next-steps","title":"Next Steps","text":"<ul> <li>Deployment - Infrastructure setup</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"guide/hierarchical/","title":"Hierarchical Limits","text":"<p>zae-limiter supports two-level hierarchies for rate limiting, enabling patterns like:</p> <ul> <li>Project \u2192 API Keys: Limit total project usage while also limiting individual keys</li> <li>Organization \u2192 Users: Organization-wide limits with per-user quotas</li> <li>Tenant \u2192 Services: Multi-tenant limits with service-level controls</li> </ul>"},{"location":"guide/hierarchical/#creating-a-hierarchy","title":"Creating a Hierarchy","text":"<pre><code># Create parent entity (project)\nawait limiter.create_entity(\n    entity_id=\"project-1\",\n    name=\"Production Project\",\n)\n\n# Create child entities (API keys)\nawait limiter.create_entity(\n    entity_id=\"key-abc\",\n    parent_id=\"project-1\",\n    name=\"Web Application Key\",\n)\n\nawait limiter.create_entity(\n    entity_id=\"key-xyz\",\n    parent_id=\"project-1\",\n    name=\"Mobile App Key\",\n)\n</code></pre>"},{"location":"guide/hierarchical/#cascade-mode","title":"Cascade Mode","text":"<p>Use <code>cascade=True</code> to apply rate limits to both the child and parent:</p> <pre><code>async with limiter.acquire(\n    entity_id=\"key-abc\",\n    resource=\"gpt-4\",\n    limits=[\n        Limit.per_minute(\"tpm\", 10_000),  # Per-key limit\n    ],\n    consume={\"tpm\": 500},\n    cascade=True,  # Also applies to parent (project-1)\n) as lease:\n    await call_api()\n</code></pre> <p>What happens:</p> <ol> <li>Check if <code>key-abc</code> has capacity (10k tpm)</li> <li>Check if <code>project-1</code> has capacity (uses same limits)</li> <li>If both pass, consume from both atomically</li> <li>If either fails, reject with details about which limit was exceeded</li> </ol>"},{"location":"guide/hierarchical/#different-limits-per-level","title":"Different Limits Per Level","text":"<p>Set different limits for parents and children:</p> <pre><code># Set project-level limits (higher)\nawait limiter.set_limits(\n    entity_id=\"project-1\",\n    limits=[\n        Limit.per_minute(\"tpm\", 100_000),  # 100k for entire project\n    ],\n)\n\n# Set key-level limits (lower)\nawait limiter.set_limits(\n    entity_id=\"key-abc\",\n    limits=[\n        Limit.per_minute(\"tpm\", 10_000),   # 10k per key\n    ],\n)\n\n# Use stored limits with cascade\nasync with limiter.acquire(\n    entity_id=\"key-abc\",\n    resource=\"gpt-4\",\n    limits=[Limit.per_minute(\"tpm\", 5_000)],  # Default\n    consume={\"tpm\": 500},\n    cascade=True,\n    use_stored_limits=True,  # Uses stored limits for both levels\n) as lease:\n    await call_api()\n</code></pre>"},{"location":"guide/hierarchical/#understanding-cascade-behavior","title":"Understanding Cascade Behavior","text":""},{"location":"guide/hierarchical/#without-cascade","title":"Without Cascade","text":"<pre><code># Only checks/consumes from key-abc\nasync with limiter.acquire(\n    entity_id=\"key-abc\",\n    resource=\"gpt-4\",\n    limits=[Limit.per_minute(\"tpm\", 10_000)],\n    consume={\"tpm\": 500},\n    cascade=False,  # Default\n) as lease:\n    ...\n</code></pre>"},{"location":"guide/hierarchical/#with-cascade","title":"With Cascade","text":"<pre><code># Checks/consumes from BOTH key-abc AND project-1\nasync with limiter.acquire(\n    entity_id=\"key-abc\",\n    resource=\"gpt-4\",\n    limits=[Limit.per_minute(\"tpm\", 10_000)],\n    consume={\"tpm\": 500},\n    cascade=True,\n) as lease:\n    ...\n</code></pre>"},{"location":"guide/hierarchical/#error-handling-with-hierarchies","title":"Error Handling with Hierarchies","text":"<p>When using cascade mode, <code>RateLimitExceeded</code> includes statuses for all entities:</p> <pre><code>try:\n    async with limiter.acquire(\n        entity_id=\"key-abc\",\n        cascade=True,\n        ...\n    ):\n        ...\nexcept RateLimitExceeded as e:\n    for status in e.statuses:\n        print(f\"Entity: {status.entity_id}\")\n        print(f\"  Limit: {status.limit_name}\")\n        print(f\"  Available: {status.available}\")\n        print(f\"  Exceeded: {status.exceeded}\")\n</code></pre>"},{"location":"guide/hierarchical/#use-cases","title":"Use Cases","text":""},{"location":"guide/hierarchical/#multi-tenant-saas","title":"Multi-Tenant SaaS","text":"<pre><code># Tenant has 1M tokens/day\nawait limiter.set_limits(\n    entity_id=\"tenant-acme\",\n    limits=[Limit.per_day(\"tpd\", 1_000_000)],\n)\n\n# Each user gets 100k tokens/day\nawait limiter.set_limits(\n    entity_id=\"user-123\",\n    limits=[Limit.per_day(\"tpd\", 100_000)],\n)\n\n# Rate limit user, cascade to tenant\nasync with limiter.acquire(\n    entity_id=\"user-123\",\n    cascade=True,\n    use_stored_limits=True,\n    ...\n):\n    ...\n</code></pre>"},{"location":"guide/hierarchical/#api-key-management","title":"API Key Management","text":"<pre><code># Project limit: 10k RPM\nawait limiter.set_limits(\n    entity_id=\"project-prod\",\n    limits=[Limit.per_minute(\"rpm\", 10_000)],\n)\n\n# Production key: 5k RPM (half of project)\nawait limiter.set_limits(\n    entity_id=\"key-prod\",\n    limits=[Limit.per_minute(\"rpm\", 5_000)],\n)\n\n# Staging key: 1k RPM\nawait limiter.set_limits(\n    entity_id=\"key-staging\",\n    limits=[Limit.per_minute(\"rpm\", 1_000)],\n)\n</code></pre>"},{"location":"guide/hierarchical/#limitations","title":"Limitations","text":"<ul> <li>Two levels only: Parent \u2192 Child (no grandparents)</li> <li>Single parent: Each entity can have at most one parent</li> <li>Cascade is optional: Must be explicitly enabled per call</li> </ul>"},{"location":"guide/hierarchical/#next-steps","title":"Next Steps","text":"<ul> <li>LLM Integration - Token estimation patterns</li> <li>Failure Modes - Handling service outages</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"guide/llm-integration/","title":"LLM Integration","text":"<p>zae-limiter is designed for LLM API rate limiting where token counts are unknown until after the call completes. This guide covers patterns for integrating with LLM providers.</p>"},{"location":"guide/llm-integration/#the-challenge","title":"The Challenge","text":"<p>LLM APIs present unique rate limiting challenges:</p> <ol> <li>Token counts are unknown upfront - You don't know how many tokens a response will use</li> <li>Multiple limits - Providers often limit both requests and tokens</li> <li>Variable costs - Different models have different token limits</li> <li>Streaming responses - Token count only known after stream completes</li> </ol>"},{"location":"guide/llm-integration/#basic-pattern-estimate-and-reconcile","title":"Basic Pattern: Estimate and Reconcile","text":"<pre><code>async with limiter.acquire(\n    entity_id=\"api-key-123\",\n    resource=\"gpt-4\",\n    limits=[\n        Limit.per_minute(\"rpm\", 100),       # Requests per minute\n        Limit.per_minute(\"tpm\", 10_000),    # Tokens per minute\n    ],\n    consume={\"rpm\": 1, \"tpm\": 500},  # Estimate 500 tokens\n) as lease:\n    response = await openai.chat.completions.create(\n        model=\"gpt-4\",\n        messages=[{\"role\": \"user\", \"content\": prompt}],\n    )\n\n    # Reconcile with actual usage\n    actual_tokens = response.usage.total_tokens\n    await lease.adjust(tpm=actual_tokens - 500)\n</code></pre>"},{"location":"guide/llm-integration/#estimation-strategies","title":"Estimation Strategies","text":""},{"location":"guide/llm-integration/#fixed-estimate","title":"Fixed Estimate","text":"<p>Simple but may over/under-estimate:</p> <pre><code>consume={\"tpm\": 500}  # Always estimate 500 tokens\n</code></pre>"},{"location":"guide/llm-integration/#input-based-estimate","title":"Input-Based Estimate","text":"<p>Estimate based on input length:</p> <pre><code>import tiktoken\n\ndef estimate_tokens(messages: list, model: str = \"gpt-4\") -&gt; int:\n    \"\"\"Estimate tokens for input messages.\"\"\"\n    encoding = tiktoken.encoding_for_model(model)\n    total = 0\n    for msg in messages:\n        total += len(encoding.encode(msg[\"content\"]))\n        total += 4  # Message overhead\n    total += 2  # Completion priming\n    return total\n\n# Use in rate limiting\ninput_tokens = estimate_tokens(messages)\nestimated_output = 500  # Rough estimate for output\ntotal_estimate = input_tokens + estimated_output\n\nasync with limiter.acquire(\n    ...\n    consume={\"tpm\": total_estimate},\n) as lease:\n    response = await call_llm()\n    actual = response.usage.total_tokens\n    await lease.adjust(tpm=actual - total_estimate)\n</code></pre>"},{"location":"guide/llm-integration/#max-tokens-estimate","title":"Max Tokens Estimate","text":"<p>Use max_tokens as upper bound:</p> <pre><code>max_tokens = 1000\n\nasync with limiter.acquire(\n    ...\n    consume={\"tpm\": input_tokens + max_tokens},\n) as lease:\n    response = await openai.chat.completions.create(\n        model=\"gpt-4\",\n        messages=messages,\n        max_tokens=max_tokens,\n    )\n    actual = response.usage.total_tokens\n    await lease.adjust(tpm=actual - (input_tokens + max_tokens))\n</code></pre>"},{"location":"guide/llm-integration/#handling-streaming-responses","title":"Handling Streaming Responses","text":"<p>For streaming responses, token count is only available after the stream completes:</p> <pre><code>async with limiter.acquire(\n    entity_id=\"api-key-123\",\n    resource=\"gpt-4\",\n    limits=[\n        Limit.per_minute(\"rpm\", 100),\n        Limit.per_minute(\"tpm\", 10_000),\n    ],\n    consume={\"rpm\": 1, \"tpm\": estimated_tokens},\n) as lease:\n    chunks = []\n    async for chunk in await openai.chat.completions.create(\n        model=\"gpt-4\",\n        messages=messages,\n        stream=True,\n    ):\n        chunks.append(chunk)\n        yield chunk  # Stream to client\n\n    # Get final usage from last chunk (OpenAI includes it)\n    if chunks[-1].usage:\n        actual = chunks[-1].usage.total_tokens\n        await lease.adjust(tpm=actual - estimated_tokens)\n</code></pre>"},{"location":"guide/llm-integration/#per-model-rate-limits","title":"Per-Model Rate Limits","text":"<p>Different models have different limits. Use the <code>resource</code> parameter:</p> <pre><code>MODEL_LIMITS = {\n    \"gpt-4\": [\n        Limit.per_minute(\"rpm\", 100),\n        Limit.per_minute(\"tpm\", 10_000),\n    ],\n    \"gpt-4-turbo\": [\n        Limit.per_minute(\"rpm\", 500),\n        Limit.per_minute(\"tpm\", 150_000),\n    ],\n    \"gpt-3.5-turbo\": [\n        Limit.per_minute(\"rpm\", 3500),\n        Limit.per_minute(\"tpm\", 90_000),\n    ],\n}\n\nasync def rate_limited_completion(\n    entity_id: str,\n    model: str,\n    messages: list,\n    estimated_tokens: int,\n):\n    limits = MODEL_LIMITS.get(model, MODEL_LIMITS[\"gpt-3.5-turbo\"])\n\n    async with limiter.acquire(\n        entity_id=entity_id,\n        resource=model,  # Different bucket per model\n        limits=limits,\n        consume={\"rpm\": 1, \"tpm\": estimated_tokens},\n    ) as lease:\n        response = await openai.chat.completions.create(\n            model=model,\n            messages=messages,\n        )\n        actual = response.usage.total_tokens\n        await lease.adjust(tpm=actual - estimated_tokens)\n        return response\n</code></pre>"},{"location":"guide/llm-integration/#negative-buckets-debt","title":"Negative Buckets (Debt)","text":"<p>zae-limiter allows buckets to go negative, which is useful when actual usage exceeds estimates:</p> <pre><code># Estimate: 500 tokens\nasync with limiter.acquire(\n    consume={\"tpm\": 500},\n    ...\n) as lease:\n    response = await call_llm()\n\n    # Actual: 2000 tokens\n    # Adjustment: 2000 - 500 = 1500\n    await lease.adjust(tpm=1500)\n    # Bucket now at -1500 tokens (in debt)\n</code></pre> <p>The debt is repaid as tokens refill over time. This ensures accurate accounting while allowing requests to complete.</p>"},{"location":"guide/llm-integration/#pre-flight-capacity-check","title":"Pre-Flight Capacity Check","text":"<p>Check capacity before making expensive calls:</p> <pre><code>async def call_with_capacity_check(\n    entity_id: str,\n    model: str,\n    messages: list,\n    estimated_tokens: int,\n):\n    limits = MODEL_LIMITS[model]\n\n    # Check available capacity\n    available = await limiter.available(\n        entity_id=entity_id,\n        resource=model,\n        limits=limits,\n    )\n\n    if available[\"tpm\"] &lt; estimated_tokens:\n        # Not enough capacity - check when it will be available\n        wait_time = await limiter.time_until_available(\n            entity_id=entity_id,\n            resource=model,\n            limits=limits,\n            needed={\"tpm\": estimated_tokens},\n        )\n        raise RetryAfter(seconds=wait_time)\n\n    # Proceed with rate-limited call\n    async with limiter.acquire(...):\n        ...\n</code></pre>"},{"location":"guide/llm-integration/#integration-with-retry-libraries","title":"Integration with Retry Libraries","text":"<p>Combine with retry libraries like <code>tenacity</code>:</p> <pre><code>from tenacity import retry, retry_if_exception_type, wait_fixed\n\n@retry(\n    retry=retry_if_exception_type(RateLimitExceeded),\n    wait=wait_fixed(1),\n)\nasync def resilient_llm_call(entity_id: str, messages: list):\n    async with limiter.acquire(\n        entity_id=entity_id,\n        resource=\"gpt-4\",\n        limits=[Limit.per_minute(\"rpm\", 100)],\n        consume={\"rpm\": 1},\n    ):\n        return await openai.chat.completions.create(\n            model=\"gpt-4\",\n            messages=messages,\n        )\n</code></pre> <p>Or use the retry information from the exception:</p> <pre><code>async def smart_retry_llm_call(entity_id: str, messages: list):\n    while True:\n        try:\n            async with limiter.acquire(...):\n                return await call_llm()\n        except RateLimitExceeded as e:\n            await asyncio.sleep(e.retry_after_seconds)\n</code></pre>"},{"location":"guide/llm-integration/#next-steps","title":"Next Steps","text":"<ul> <li>Failure Modes - Handling service outages</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"infra/cloudformation/","title":"CloudFormation Template","text":"<p>This guide covers the CloudFormation template used by zae-limiter and how to customize it.</p>"},{"location":"infra/cloudformation/#template-overview","title":"Template Overview","text":"<p>The template creates:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                CloudFormation Stack                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502\n\u2502  \u2502  DynamoDB   \u2502\u2500\u2500\u2500\u25b6\u2502   Stream    \u2502                 \u2502\n\u2502  \u2502   Table     \u2502    \u2502             \u2502                 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2502\n\u2502                            \u2502                         \u2502\n\u2502                            \u25bc                         \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                  \u2502\n\u2502                    \u2502   Lambda    \u2502                  \u2502\n\u2502                    \u2502 Aggregator  \u2502                  \u2502\n\u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2502\n\u2502                            \u2502                         \u2502\n\u2502                            \u25bc                         \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                  \u2502\n\u2502                    \u2502 CloudWatch  \u2502                  \u2502\n\u2502                    \u2502    Logs     \u2502                  \u2502\n\u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"infra/cloudformation/#export-template","title":"Export Template","text":"<pre><code># Export to file\nzae-limiter cfn-template &gt; template.yaml\n\n# View template\nzae-limiter cfn-template | less\n</code></pre>"},{"location":"infra/cloudformation/#template-parameters","title":"Template Parameters","text":"Parameter Type Default Description <code>TableName</code> String <code>rate_limits</code> DynamoDB table name <code>SnapshotWindows</code> String <code>hourly,daily</code> Comma-separated list of snapshot windows <code>SnapshotRetentionDays</code> Number <code>90</code> Days to retain usage snapshots (1-3650) <code>LambdaMemorySize</code> Number <code>256</code> Memory for aggregator Lambda (128-3008 MB) <code>LambdaTimeout</code> Number <code>60</code> Timeout for aggregator Lambda (1-900 seconds) <code>EnableAggregator</code> String <code>true</code> Whether to deploy the aggregator Lambda <code>SchemaVersion</code> String <code>1.0.0</code> Schema version for infrastructure <code>PITRRecoveryPeriodDays</code> String (empty) PITR period (1-35 days, empty for AWS default) <code>EnableAlarms</code> String <code>true</code> Whether to deploy CloudWatch alarms <code>AlarmSNSTopicArn</code> String (empty) SNS topic ARN for alarm notifications <code>LogRetentionDays</code> Number <code>30</code> CloudWatch log retention (standard periods)"},{"location":"infra/cloudformation/#dynamodb-table","title":"DynamoDB Table","text":""},{"location":"infra/cloudformation/#schema","title":"Schema","text":"<pre><code>AttributeDefinitions:\n  - AttributeName: PK\n    AttributeType: S\n  - AttributeName: SK\n    AttributeType: S\n  - AttributeName: GSI1PK\n    AttributeType: S\n  - AttributeName: GSI1SK\n    AttributeType: S\n  - AttributeName: GSI2PK\n    AttributeType: S\n  - AttributeName: GSI2SK\n    AttributeType: S\n\nKeySchema:\n  - AttributeName: PK\n    KeyType: HASH\n  - AttributeName: SK\n    KeyType: RANGE\n</code></pre>"},{"location":"infra/cloudformation/#global-secondary-indexes","title":"Global Secondary Indexes","text":"<p>GSI1 - Parent to children lookups:</p> <pre><code>GlobalSecondaryIndexes:\n  - IndexName: GSI1\n    KeySchema:\n      - AttributeName: GSI1PK  # PARENT#{parent_id}\n        KeyType: HASH\n      - AttributeName: GSI1SK  # CHILD#{child_id}\n        KeyType: RANGE\n</code></pre> <p>GSI2 - Resource aggregation:</p> <pre><code>  - IndexName: GSI2\n    KeySchema:\n      - AttributeName: GSI2PK  # RESOURCE#{resource}\n        KeyType: HASH\n      - AttributeName: GSI2SK  # BUCKET#{entity_id}#{limit_name}\n        KeyType: RANGE\n</code></pre>"},{"location":"infra/cloudformation/#stream-configuration","title":"Stream Configuration","text":"<pre><code>StreamSpecification:\n  StreamViewType: NEW_AND_OLD_IMAGES\n</code></pre>"},{"location":"infra/cloudformation/#lambda-aggregator","title":"Lambda Aggregator","text":""},{"location":"infra/cloudformation/#function-configuration","title":"Function Configuration","text":"<pre><code>AggregatorFunction:\n  Type: AWS::Lambda::Function\n  Properties:\n    Runtime: python3.12\n    Handler: zae_limiter.aggregator.handler.lambda_handler\n    MemorySize: 256\n    Timeout: 60\n    Environment:\n      Variables:\n        TABLE_NAME: !Ref TableName\n        SNAPSHOT_WINDOWS: !Ref SnapshotWindows\n        RETENTION_DAYS: !Ref SnapshotRetentionDays\n</code></pre>"},{"location":"infra/cloudformation/#event-source-mapping","title":"Event Source Mapping","text":"<pre><code>StreamEventMapping:\n  Type: AWS::Lambda::EventSourceMapping\n  Properties:\n    EventSourceArn: !GetAtt Table.StreamArn\n    FunctionName: !Ref AggregatorFunction\n    StartingPosition: LATEST\n    BatchSize: 100\n    MaximumBatchingWindowInSeconds: 5\n</code></pre>"},{"location":"infra/cloudformation/#iam-permissions","title":"IAM Permissions","text":""},{"location":"infra/cloudformation/#lambda-execution-role","title":"Lambda Execution Role","text":"<pre><code>AggregatorRole:\n  Type: AWS::IAM::Role\n  Properties:\n    AssumeRolePolicyDocument:\n      Statement:\n        - Effect: Allow\n          Principal:\n            Service: lambda.amazonaws.com\n          Action: sts:AssumeRole\n    Policies:\n      - PolicyName: DynamoDBAccess\n        PolicyDocument:\n          Statement:\n            - Effect: Allow\n              Action:\n                - dynamodb:GetItem\n                - dynamodb:PutItem\n                - dynamodb:UpdateItem\n                - dynamodb:Query\n              Resource: !GetAtt Table.Arn\n            - Effect: Allow\n              Action:\n                - dynamodb:GetRecords\n                - dynamodb:GetShardIterator\n                - dynamodb:DescribeStream\n                - dynamodb:ListStreams\n              Resource: !Sub \"${Table.Arn}/stream/*\"\n</code></pre>"},{"location":"infra/cloudformation/#customization","title":"Customization","text":""},{"location":"infra/cloudformation/#add-dead-letter-queue","title":"Add Dead Letter Queue","text":"<pre><code>Parameters:\n  EnableDLQ:\n    Type: String\n    Default: \"false\"\n    AllowedValues: [\"true\", \"false\"]\n\nConditions:\n  CreateDLQ: !Equals [!Ref EnableDLQ, \"true\"]\n\nResources:\n  DeadLetterQueue:\n    Type: AWS::SQS::Queue\n    Condition: CreateDLQ\n    Properties:\n      QueueName: !Sub \"${TableName}-dlq\"\n      MessageRetentionPeriod: 1209600  # 14 days\n\n  StreamEventMapping:\n    Properties:\n      DestinationConfig:\n        OnFailure:\n          Destination: !If\n            - CreateDLQ\n            - !GetAtt DeadLetterQueue.Arn\n            - !Ref AWS::NoValue\n</code></pre>"},{"location":"infra/cloudformation/#add-cloudwatch-alarms","title":"Add CloudWatch Alarms","text":"<pre><code>ThrottleAlarm:\n  Type: AWS::CloudWatch::Alarm\n  Properties:\n    AlarmName: !Sub \"${TableName}-throttle\"\n    MetricName: ThrottledRequests\n    Namespace: AWS/DynamoDB\n    Dimensions:\n      - Name: TableName\n        Value: !Ref Table\n    Statistic: Sum\n    Period: 60\n    EvaluationPeriods: 1\n    Threshold: 1\n    ComparisonOperator: GreaterThanOrEqualToThreshold\n    AlarmActions:\n      - !Ref AlertTopic\n</code></pre>"},{"location":"infra/cloudformation/#enable-encryption-with-cmk","title":"Enable Encryption with CMK","text":"<pre><code>Parameters:\n  KmsKeyArn:\n    Type: String\n    Default: \"\"\n\nConditions:\n  UseCustomKey: !Not [!Equals [!Ref KmsKeyArn, \"\"]]\n\nResources:\n  Table:\n    Properties:\n      SSESpecification:\n        SSEEnabled: true\n        SSEType: !If [UseCustomKey, \"KMS\", \"AWS_OWNED_KEY\"]\n        KMSMasterKeyId: !If [UseCustomKey, !Ref KmsKeyArn, !Ref AWS::NoValue]\n</code></pre>"},{"location":"infra/cloudformation/#deployment-examples","title":"Deployment Examples","text":""},{"location":"infra/cloudformation/#basic-deployment","title":"Basic Deployment","text":"<pre><code>aws cloudformation deploy \\\n    --template-file template.yaml \\\n    --stack-name zae-limiter \\\n    --capabilities CAPABILITY_NAMED_IAM\n</code></pre>"},{"location":"infra/cloudformation/#with-custom-parameters","title":"With Custom Parameters","text":"<pre><code>aws cloudformation deploy \\\n    --template-file template.yaml \\\n    --stack-name zae-limiter-prod \\\n    --parameter-overrides \\\n        TableName=prod_rate_limits \\\n        PITRRecoveryPeriodDays=35 \\\n        SnapshotRetentionDays=365 \\\n        LogRetentionDays=90 \\\n        EnableAlarms=true \\\n    --capabilities CAPABILITY_NAMED_IAM\n</code></pre>"},{"location":"infra/cloudformation/#using-sam","title":"Using SAM","text":"<pre><code># samconfig.toml\n[default.deploy.parameters]\nstack_name = \"zae-limiter\"\ncapabilities = \"CAPABILITY_NAMED_IAM\"\nparameter_overrides = \"TableName=rate_limits\"\n</code></pre> <pre><code>sam deploy --guided\n</code></pre>"},{"location":"infra/cloudformation/#outputs","title":"Outputs","text":"<p>The template exports:</p> Output Description <code>TableName</code> DynamoDB table name <code>TableArn</code> DynamoDB table ARN <code>StreamArn</code> DynamoDB stream ARN <code>FunctionArn</code> Lambda function ARN <p>Access outputs:</p> <pre><code>aws cloudformation describe-stacks \\\n    --stack-name zae-limiter \\\n    --query \"Stacks[0].Outputs\"\n</code></pre>"},{"location":"infra/cloudformation/#next-steps","title":"Next Steps","text":"<ul> <li>Deployment - Deployment guide</li> <li>LocalStack - Local development</li> </ul>"},{"location":"infra/deployment/","title":"Deployment","text":"<p>This guide covers deploying zae-limiter infrastructure to AWS.</p>"},{"location":"infra/deployment/#overview","title":"Overview","text":"<p>zae-limiter uses CloudFormation to deploy:</p> <ul> <li>DynamoDB Table - Stores rate limit state, entities, and usage data</li> <li>DynamoDB Streams - Captures changes for usage aggregation</li> <li>Lambda Function - Aggregates usage into hourly/daily snapshots</li> <li>IAM Roles - Least-privilege access for Lambda</li> <li>CloudWatch Logs - Lambda function logs</li> </ul>"},{"location":"infra/deployment/#cli-deployment-recommended","title":"CLI Deployment (Recommended)","text":"<p>The simplest way to deploy:</p> <pre><code># Deploy with defaults\nzae-limiter deploy --table-name rate_limits --region us-east-1\n\n# Deploy with custom settings\nzae-limiter deploy \\\n    --table-name rate_limits \\\n    --region us-east-1 \\\n    --log-retention-days 90 \\\n    --pitr-recovery-days 7\n</code></pre>"},{"location":"infra/deployment/#cli-options","title":"CLI Options","text":"Option Description Default <code>--table-name</code> DynamoDB table name Required <code>--region</code> AWS region Required <code>--stack-name</code> CloudFormation stack name <code>zae-limiter-{table}</code> <code>--no-aggregator</code> Skip Lambda deployment <code>false</code> <code>--log-retention-days</code> CloudWatch log retention <code>14</code> <code>--pitr-recovery-days</code> Point-in-time recovery <code>0</code> (disabled) <code>--endpoint-url</code> Custom endpoint (LocalStack) None"},{"location":"infra/deployment/#check-stack-status","title":"Check Stack Status","text":"<pre><code>zae-limiter status --stack-name zae-limiter-rate_limits --region us-east-1\n</code></pre>"},{"location":"infra/deployment/#delete-stack","title":"Delete Stack","text":"<pre><code>zae-limiter delete --stack-name zae-limiter-rate_limits --region us-east-1 --yes\n</code></pre>"},{"location":"infra/deployment/#stack-lifecycle-management","title":"Stack Lifecycle Management","text":""},{"location":"infra/deployment/#programmatic-cleanup","title":"Programmatic Cleanup","text":"<p>In addition to the CLI, you can manage stack lifecycle programmatically using the <code>delete_stack()</code> method:</p> <pre><code>from zae_limiter import RateLimiter, StackOptions\n\n# Create stack\nlimiter = RateLimiter(\n    table_name=\"rate_limits\",\n    region=\"us-east-1\",\n    stack_options=StackOptions(),\n)\n\n# Use the limiter...\nasync with limiter:\n    # Rate limiting operations here\n    pass\n\n# Delete stack when done\nawait limiter.delete_stack()\n</code></pre>"},{"location":"infra/deployment/#use-case-guidance","title":"Use-Case Guidance","text":""},{"location":"infra/deployment/#development-and-prototyping","title":"Development and Prototyping","text":"<p>For rapid iteration, use auto-creation with cleanup:</p> <pre><code>async def dev_session():\n    limiter = RateLimiter(\n        table_name=\"dev_limits\",\n        region=\"us-east-1\",\n        stack_options=StackOptions(enable_aggregator=False),\n    )\n\n    try:\n        async with limiter:\n            # Development work...\n            pass\n    finally:\n        # Clean up development stack\n        await limiter.delete_stack()\n</code></pre>"},{"location":"infra/deployment/#integration-testing","title":"Integration Testing","text":"<p>For test isolation, create/destroy stacks per test session:</p> <pre><code>import pytest\nimport uuid\nfrom zae_limiter import RateLimiter, StackOptions\n\n@pytest.fixture(scope=\"session\")\nasync def integration_limiter():\n    \"\"\"Session-scoped fixture with automatic cleanup.\"\"\"\n    limiter = RateLimiter(\n        table_name=f\"test_{uuid.uuid4().hex[:8]}\",  # Unique name\n        endpoint_url=\"http://localhost:4566\",\n        region=\"us-east-1\",\n        stack_options=StackOptions(enable_aggregator=False),\n    )\n\n    async with limiter:\n        yield limiter\n\n    await limiter.delete_stack()\n</code></pre>"},{"location":"infra/deployment/#production-deployments","title":"Production Deployments","text":"<p>For production, prefer CLI or CloudFormation-managed deployments:</p> <pre><code># Deploy via CLI (with review)\nzae-limiter deploy --table-name prod_limits --region us-east-1\n\n# Delete via CLI (requires confirmation)\nzae-limiter delete --stack-name zae-limiter-prod_limits --region us-east-1\n</code></pre> <p>Production Best Practice</p> <p>In production, avoid programmatic <code>delete_stack()</code> calls. Use:</p> <ul> <li>CloudFormation console for manual cleanup</li> <li>CLI with <code>--yes</code> flag for scripted cleanup (after review)</li> <li>Stack policies to prevent accidental deletion</li> </ul>"},{"location":"infra/deployment/#cloudformation-template","title":"CloudFormation Template","text":"<p>Export and customize the template:</p> <pre><code># Export template\nzae-limiter cfn-template &gt; template.yaml\n\n# Deploy with AWS CLI\naws cloudformation deploy \\\n    --template-file template.yaml \\\n    --stack-name zae-limiter \\\n    --parameter-overrides \\\n        TableName=rate_limits \\\n        SnapshotRetentionDays=90 \\\n        EnablePITR=true \\\n    --capabilities CAPABILITY_NAMED_IAM\n\n# Deploy Lambda code separately\nzae-limiter lambda-export --output lambda.zip\naws lambda update-function-code \\\n    --function-name zae-limiter-aggregator \\\n    --zip-file fileb://lambda.zip\n</code></pre>"},{"location":"infra/deployment/#template-parameters","title":"Template Parameters","text":"Parameter Description Default <code>TableName</code> DynamoDB table name <code>rate_limits</code> <code>SnapshotWindows</code> Aggregation windows <code>hourly,daily</code> <code>SnapshotRetentionDays</code> Usage data retention <code>90</code> <code>EnablePITR</code> Point-in-time recovery <code>false</code> <code>LogRetentionDays</code> CloudWatch log retention <code>14</code>"},{"location":"infra/deployment/#auto-creation-in-code","title":"Auto-Creation in Code","text":"<p>For development, create infrastructure programmatically:</p> <pre><code>from zae_limiter import RateLimiter\n\nlimiter = RateLimiter(\n    table_name=\"rate_limits\",\n    region=\"us-east-1\",\n    create_stack=True,\n    stack_parameters={\n        \"snapshot_windows\": \"hourly,daily\",\n        \"retention_days\": \"90\",\n    },\n)\n</code></pre> <p>Production Use</p> <p>Auto-creation is convenient for development but has limitations:</p> <ul> <li>No control over IAM policies</li> <li>Limited error handling</li> <li>Not idempotent</li> </ul> <p>Use CLI or CloudFormation for production.</p>"},{"location":"infra/deployment/#infrastructure-details","title":"Infrastructure Details","text":""},{"location":"infra/deployment/#dynamodb-table","title":"DynamoDB Table","text":"<ul> <li>Billing: Pay-per-request (on-demand)</li> <li>Encryption: AWS-managed keys (default)</li> <li>Streams: NEW_AND_OLD_IMAGES for Lambda trigger</li> </ul>"},{"location":"infra/deployment/#dynamodb-schema","title":"DynamoDB Schema","text":"Key Pattern Purpose PK <code>ENTITY#{id}</code> Partition key SK <code>#META</code>, <code>#BUCKET#...</code>, <code>#LIMIT#...</code> Sort key GSI1PK <code>PARENT#{id}</code> Parent lookups GSI2PK <code>RESOURCE#{name}</code> Resource aggregation"},{"location":"infra/deployment/#lambda-function","title":"Lambda Function","text":"<ul> <li>Runtime: Python 3.12</li> <li>Memory: 256 MB</li> <li>Timeout: 60 seconds</li> <li>Trigger: DynamoDB Streams</li> </ul>"},{"location":"infra/deployment/#iam-permissions","title":"IAM Permissions","text":"<p>The Lambda function has minimal permissions:</p> <pre><code>- dynamodb:GetItem\n- dynamodb:PutItem\n- dynamodb:UpdateItem\n- dynamodb:Query\n</code></pre>"},{"location":"infra/deployment/#monitoring","title":"Monitoring","text":""},{"location":"infra/deployment/#cloudwatch-metrics","title":"CloudWatch Metrics","text":"<p>DynamoDB provides built-in metrics:</p> <ul> <li><code>ConsumedReadCapacityUnits</code></li> <li><code>ConsumedWriteCapacityUnits</code></li> <li><code>ThrottledRequests</code></li> <li><code>SystemErrors</code></li> </ul>"},{"location":"infra/deployment/#cloudwatch-alarms","title":"CloudWatch Alarms","text":"<p>The stack includes optional alarms:</p> <pre><code>zae-limiter deploy \\\n    --table-name rate_limits \\\n    --enable-alarms \\\n    --alarm-sns-topic arn:aws:sns:us-east-1:123456789:alerts\n</code></pre>"},{"location":"infra/deployment/#lambda-monitoring","title":"Lambda Monitoring","text":"<p>Monitor the aggregator function:</p> <ul> <li>Invocation count</li> <li>Error rate</li> <li>Duration</li> <li>Iterator age (stream lag)</li> </ul>"},{"location":"infra/deployment/#cost-estimation","title":"Cost Estimation","text":"Component Cost Driver DynamoDB Read/write capacity units Lambda Invocations, duration CloudWatch Log storage, metrics <p>For a typical workload (1M requests/day):</p> <ul> <li>DynamoDB: ~$10-50/month</li> <li>Lambda: ~$1-5/month</li> <li>CloudWatch: ~$1-5/month</li> </ul>"},{"location":"infra/deployment/#next-steps","title":"Next Steps","text":"<ul> <li>LocalStack - Local development setup</li> <li>CloudFormation - Template details</li> </ul>"},{"location":"infra/localstack/","title":"LocalStack Development","text":"<p>LocalStack provides a local AWS environment for development and testing. This guide covers setting up zae-limiter with LocalStack.</p>"},{"location":"infra/localstack/#why-localstack","title":"Why LocalStack?","text":"<ul> <li>Free - No AWS costs during development</li> <li>Fast - No network latency</li> <li>Isolated - No risk to production data</li> <li>Full stack - DynamoDB, Lambda, Streams, CloudFormation</li> </ul>"},{"location":"infra/localstack/#quick-start","title":"Quick Start","text":""},{"location":"infra/localstack/#1-start-localstack","title":"1. Start LocalStack","text":"DockerDocker ComposeLocalStack CLI <pre><code>docker run -d \\\n  --name localstack \\\n  -p 4566:4566 \\\n  -e SERVICES=dynamodb,dynamodbstreams,lambda,cloudformation,logs,iam,cloudwatch,sqs \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -v \"${TMPDIR:-/tmp}/localstack:/var/lib/localstack\" \\\n  localstack/localstack\n</code></pre> <p>Docker Socket Required</p> <p>The Docker socket mount (<code>-v /var/run/docker.sock:/var/run/docker.sock</code>) is required for LocalStack to spawn Lambda functions as Docker containers.</p> <pre><code># docker-compose.yml\nservices:\n  localstack:\n    image: localstack/localstack\n    ports:\n      - \"4566:4566\"\n    environment:\n      - SERVICES=dynamodb,dynamodbstreams,lambda,cloudformation,logs,iam,cloudwatch,sqs\n      - DEBUG=0\n    volumes:\n      - \"/var/run/docker.sock:/var/run/docker.sock\"\n      - \"./localstack:/var/lib/localstack\"\n</code></pre> <pre><code>docker compose up -d\n</code></pre> <pre><code>pip install localstack\nlocalstack start -d\n</code></pre>"},{"location":"infra/localstack/#2-deploy-infrastructure","title":"2. Deploy Infrastructure","text":"<pre><code>zae-limiter deploy \\\n    --table-name rate_limits \\\n    --endpoint-url http://localhost:4566 \\\n    --region us-east-1\n</code></pre>"},{"location":"infra/localstack/#3-use-in-code","title":"3. Use in Code","text":"<pre><code>from zae_limiter import RateLimiter, Limit\n\nlimiter = RateLimiter(\n    table_name=\"rate_limits\",\n    endpoint_url=\"http://localhost:4566\",\n    region=\"us-east-1\",\n)\n\nasync with limiter.acquire(\n    entity_id=\"test-user\",\n    resource=\"api\",\n    limits=[Limit.per_minute(\"requests\", 100)],\n    consume={\"requests\": 1},\n) as lease:\n    print(\"Rate limited request!\")\n</code></pre>"},{"location":"infra/localstack/#auto-creation-mode","title":"Auto-Creation Mode","text":"<p>For quick iteration, use auto-creation:</p> <pre><code>limiter = RateLimiter(\n    table_name=\"rate_limits\",\n    endpoint_url=\"http://localhost:4566\",\n    region=\"us-east-1\",\n    create_stack=True,  # Creates CloudFormation stack\n)\n</code></pre>"},{"location":"infra/localstack/#environment-variables","title":"Environment Variables","text":"<p>Configure via environment variables for easy switching:</p> <pre><code># .env.local\nAWS_ENDPOINT_URL=http://localhost:4566\nAWS_ACCESS_KEY_ID=test\nAWS_SECRET_ACCESS_KEY=test\nAWS_DEFAULT_REGION=us-east-1\n</code></pre> <pre><code>import os\n\nlimiter = RateLimiter(\n    table_name=\"rate_limits\",\n    endpoint_url=os.getenv(\"AWS_ENDPOINT_URL\"),\n    region=os.getenv(\"AWS_DEFAULT_REGION\", \"us-east-1\"),\n)\n</code></pre>"},{"location":"infra/localstack/#testing-with-localstack","title":"Testing with LocalStack","text":""},{"location":"infra/localstack/#pytest-fixture-with-cleanup","title":"pytest Fixture with Cleanup","text":"<p>For integration tests, use fixtures that properly clean up resources:</p> <pre><code>import os\nimport uuid\nimport pytest\nfrom zae_limiter import RateLimiter, StackOptions\n\n@pytest.fixture\ndef localstack_endpoint():\n    \"\"\"Get LocalStack endpoint from environment.\"\"\"\n    return os.getenv(\"AWS_ENDPOINT_URL\", \"http://localhost:4566\")\n\n@pytest.fixture(scope=\"function\")\nasync def limiter(localstack_endpoint):\n    \"\"\"\n    Create a rate limiter connected to LocalStack with automatic cleanup.\n\n    This fixture:\n    1. Creates a unique stack for test isolation\n    2. Yields the limiter for test use\n    3. Deletes the stack in teardown\n    \"\"\"\n    # Unique table name prevents test interference\n    table_name = f\"test_{uuid.uuid4().hex[:8]}\"\n\n    limiter = RateLimiter(\n        table_name=table_name,\n        endpoint_url=localstack_endpoint,\n        region=\"us-east-1\",\n        stack_options=StackOptions(enable_aggregator=False),\n    )\n\n    async with limiter:\n        yield limiter\n\n    # Cleanup: delete the CloudFormation stack\n    await limiter.delete_stack()\n\n@pytest.mark.integration\nasync def test_rate_limiting(limiter):\n    async with limiter.acquire(\n        entity_id=\"test-user\",\n        resource=\"api\",\n        limits=[Limit.per_minute(\"requests\", 10)],\n        consume={\"requests\": 1},\n    ):\n        pass  # Success\n</code></pre>"},{"location":"infra/localstack/#session-scoped-fixture-faster","title":"Session-Scoped Fixture (Faster)","text":"<p>For test suites where stack creation overhead is significant:</p> <pre><code>@pytest.fixture(scope=\"session\")\nasync def shared_limiter(localstack_endpoint):\n    \"\"\"\n    Session-scoped limiter for faster test execution.\n\n    Trade-off: Tests share state, less isolation.\n    \"\"\"\n    limiter = RateLimiter(\n        table_name=\"integration_test_shared\",\n        endpoint_url=localstack_endpoint,\n        region=\"us-east-1\",\n        stack_options=StackOptions(enable_aggregator=False),\n    )\n\n    async with limiter:\n        yield limiter\n\n    await limiter.delete_stack()\n</code></pre>"},{"location":"infra/localstack/#sync-fixture-example","title":"Sync Fixture Example","text":"<pre><code>@pytest.fixture(scope=\"function\")\ndef sync_limiter(localstack_endpoint):\n    \"\"\"Synchronous rate limiter with cleanup.\"\"\"\n    from zae_limiter import SyncRateLimiter, StackOptions\n    import uuid\n\n    table_name = f\"test_sync_{uuid.uuid4().hex[:8]}\"\n\n    limiter = SyncRateLimiter(\n        table_name=table_name,\n        endpoint_url=localstack_endpoint,\n        region=\"us-east-1\",\n        stack_options=StackOptions(enable_aggregator=False),\n    )\n\n    with limiter:\n        yield limiter\n\n    limiter.delete_stack()\n</code></pre>"},{"location":"infra/localstack/#ci-configuration","title":"CI Configuration","text":"<pre><code># .github/workflows/ci.yml\njobs:\n  integration:\n    runs-on: ubuntu-latest\n    services:\n      localstack:\n        image: localstack/localstack\n        ports:\n          - 4566:4566\n        env:\n          SERVICES: dynamodb,dynamodbstreams,lambda,cloudformation,logs,iam,cloudwatch,sqs\n        options: &gt;-\n          --mount type=bind,source=/var/run/docker.sock,target=/var/run/docker.sock\n    steps:\n      - uses: actions/checkout@v4\n      - run: pip install -e \".[dev]\"\n      - run: pytest -m integration\n        env:\n          AWS_ENDPOINT_URL: http://localhost:4566\n          AWS_ACCESS_KEY_ID: test\n          AWS_SECRET_ACCESS_KEY: test\n</code></pre>"},{"location":"infra/localstack/#debugging","title":"Debugging","text":""},{"location":"infra/localstack/#check-stack-status","title":"Check Stack Status","text":"<pre><code># List stacks\naws --endpoint-url=http://localhost:4566 cloudformation list-stacks\n\n# Describe stack\naws --endpoint-url=http://localhost:4566 cloudformation describe-stacks \\\n    --stack-name zae-limiter-rate_limits\n</code></pre>"},{"location":"infra/localstack/#inspect-dynamodb","title":"Inspect DynamoDB","text":"<pre><code># List tables\naws --endpoint-url=http://localhost:4566 dynamodb list-tables\n\n# Scan table\naws --endpoint-url=http://localhost:4566 dynamodb scan \\\n    --table-name rate_limits\n</code></pre>"},{"location":"infra/localstack/#view-lambda-logs","title":"View Lambda Logs","text":"<pre><code># List functions\naws --endpoint-url=http://localhost:4566 lambda list-functions\n\n# Get logs\naws --endpoint-url=http://localhost:4566 logs tail \\\n    /aws/lambda/zae-limiter-aggregator\n</code></pre>"},{"location":"infra/localstack/#localstack-vs-dynamodb-local","title":"LocalStack vs DynamoDB Local","text":"Feature LocalStack DynamoDB Local DynamoDB Yes Yes Streams Yes Limited Lambda Yes No CloudFormation Yes No Cost Free Free Fidelity High Medium <p>Recommendation: Use LocalStack for full integration testing, DynamoDB Local for quick unit tests.</p>"},{"location":"infra/localstack/#troubleshooting","title":"Troubleshooting","text":""},{"location":"infra/localstack/#connection-refused","title":"Connection Refused","text":"<pre><code>Cannot connect to http://localhost:4566\n</code></pre> <p>Solution: Ensure LocalStack is running:</p> <pre><code>docker ps | grep localstack\n# or\ncurl http://localhost:4566/_localstack/health\n</code></pre>"},{"location":"infra/localstack/#lambda-not-executing","title":"Lambda Not Executing","text":"<p>Check Lambda logs:</p> <pre><code>docker logs localstack 2&gt;&amp;1 | grep -i lambda\n</code></pre> <p>Ensure the Lambda service is enabled:</p> <pre><code>docker run -e SERVICES=dynamodb,dynamodbstreams,lambda,...\n</code></pre>"},{"location":"infra/localstack/#slow-performance","title":"Slow Performance","text":"<p>LocalStack can be slow on first request. Consider:</p> <ul> <li>Pre-warming containers</li> <li>Using persistence for faster restarts</li> <li>Reducing DEBUG level</li> </ul>"},{"location":"infra/localstack/#next-steps","title":"Next Steps","text":"<ul> <li>Deployment - Production deployment</li> <li>CloudFormation - Template customization</li> </ul>"}]}